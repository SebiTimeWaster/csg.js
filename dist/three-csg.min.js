const e=function(e){if(!e.cachedBoundingBox){let t=new J(0,0,0),n=new J(0,0,0),r=e.polygons,i=r.length;for(let e=0;e<i;e++){let i=r[e].boundingBox();0===e?(t=i[0],n=i[1]):(t=t.min(i[0]),n=n.max(i[1]))}e.cachedBoundingBox=[t,n]}return e.cachedBoundingBox},t=Object.freeze({_CSGDEBUG:!1,defaultResolution2D:32,defaultResolution3D:12,EPS:1e-5,angleEPS:.1,areaEPS:49916708323414084e-28,all:0,top:1,bottom:2,left:3,right:4,front:5,back:6}),n=function(e){e.mirrored=function(e){return this.transform(X.mirroring(e))},e.mirroredX=function(){let e=new L(J.Create(1,0,0),0);return this.mirrored(e)},e.mirroredY=function(){let e=new L(J.Create(0,1,0),0);return this.mirrored(e)},e.mirroredZ=function(){let e=new L(J.Create(0,0,1),0);return this.mirrored(e)},e.translate=function(e){return this.transform(X.translation(e))},e.scale=function(e){return this.transform(X.scaling(e))},e.rotateX=function(e){return this.transform(X.rotationX(e))},e.rotateY=function(e){return this.transform(X.rotationY(e))},e.rotateZ=function(e){return this.transform(X.rotationZ(e))},e.rotate=function(e,t,n){return this.transform(X.rotation(e,t,n))},e.rotateEulerAngles=function(e,t,n,r){r=r||[0,0,0];let i=X.rotationZ(e),o=X.rotationX(t),s=X.rotationZ(n),l=X.translation(new J(r));return this.transform(s.multiply(o).multiply(i).multiply(l))}},r=function(e,t,n){this.point=new J(e),this.axisvector=new J(t).unit(),this.normalvector=new J(n).unit()};r.prototype={normalized:function(){let e=this.axisvector.unit(),t=this.normalvector.cross(e).unit(),n=e.cross(t);return new r(this.point,e,n)},transform:function(e){let t=this.point.multiply4x4(e),n=this.point.plus(this.axisvector).multiply4x4(e).minus(t),i=this.point.plus(this.normalvector).multiply4x4(e).minus(t);return new r(t,n,i)},getTransformationTo:function(e,t,n){t=!!t,n=n?Number(n):0;let r=this.normalized();e=e.normalized();let i=X.translation(this.point.negated()),o=L.anyPlaneFromVector3Ds(new J(0,0,0),r.axisvector,e.axisvector),s=new Y(o),l=s.to2D(r.axisvector).angle(),a=s.to2D(e.axisvector).angle(),u=180*(a-l)/Math.PI;t&&(u+=180),i=i.multiply(s.getProjectionMatrix()),i=i.multiply(X.rotationZ(u)),i=i.multiply(s.getInverseProjectionMatrix());let h=r.transform(i),c=L.fromNormalAndPoint(e.axisvector,new J(0,0,0)),p=new Y(c);return l=p.to2D(h.normalvector).angle(),a=p.to2D(e.normalvector).angle(),u=180*(a-l)/Math.PI,u+=n,i=i.multiply(p.getProjectionMatrix()),i=i.multiply(X.rotationZ(u)),i=i.multiply(p.getInverseProjectionMatrix()),i=i.multiply(X.translation(e.point)),i},axisLine:function(){return new G(this.point,this.axisvector)},extend:function(e){let t=this.point.plus(this.axisvector.unit().times(e));return new r(t,this.axisvector,this.normalvector)}};let i=function(){this.sides=[],this.isCanonicalized=!1};i.prototype={union:function(e){let t;t=e instanceof Array?e:[e];let n=this._toCSGWall(-1,1);return n=n.union(t.map((function(e){return e._toCSGWall(-1,1).reTesselated()})),!1,!1),d(n).canonicalized()},subtract:function(e){let t;t=e instanceof Array?e:[e];let n=this._toCSGWall(-1,1);return t.map((function(e){n=n.subtractSub(e._toCSGWall(-1,1),!1,!1)})),n=n.reTesselated(),n=n.canonicalized(),n=d(n),n=n.canonicalized(),n},intersect:function(e){let t;t=e instanceof Array?e:[e];let n=this._toCSGWall(-1,1);return t.map((function(e){n=n.intersectSub(e._toCSGWall(-1,1),!1,!1)})),n=n.reTesselated(),n=n.canonicalized(),n=d(n),n=n.canonicalized(),n},transform:function(e){let t=e.isMirroring(),n=this.sides.map((function(t){return t.transform(e)})),r=m(n);return t&&(r=r.flipped()),r},flipped:function(){let e=this.sides.map((function(e){return e.flipped()}));return e.reverse(),m(e)},center:function(e){return Ve({axes:e},[this])},expandedShell:function(e,t){return we(this,e,t)},expand:function(e,t){return de(this,e,t)},contract:function(e,t){return ge(this,e,t)},area:function(){return function(e){let t=0;return e.sides.map((function(e){t+=e.vertex0.pos.cross(e.vertex1.pos)})),t*=.5,t}(this)},getBounds:function(){return function(e){let t;t=0===e.sides.length?new K(0,0):e.sides[0].vertex0.pos;let n=t;return e.sides.map((function(e){t=t.min(e.vertex0.pos),t=t.min(e.vertex1.pos),n=n.max(e.vertex0.pos),n=n.max(e.vertex1.pos)})),[t,n]}(this)},isSelfIntersecting:function(e){return R(this,e)},extrudeInOrthonormalBasis:function(e,t,n){return xe(this,e,t,n)},extrudeInPlane:function(e,t,n,r){return ve(this,e,t,n,r)},extrude:function(e){return _e(this,e)},rotateExtrude:function(e){return be(this,e)},check:function(){return N(this)},canonicalized:function(){return v(this)},reTesselated:function(){return retesselate(this)},getOutlinePaths:function(){return pe(this)},overCutInsideCorners:function(e){return Me(this,e)},hasPointInside:function(e){return j(this,e)},toString:function(){let e="CAG ("+this.sides.length+" sides):\n";return this.sides.map((function(t){e+="  "+t.toString()+"\n"})),e},_toCSGWall:function(e,t){let n=this.sides.map((function(n){return n.toPolygon3D(e,t)}));return f(n)},_toVector3DPairs:function(e){let t=this.sides.map((function(e){let t=e.vertex0.pos,n=e.vertex1.pos;return[J.Create(t.x,t.y,0),J.Create(n.x,n.y,0)]}));return void 0!==e&&(t=t.map((function(t){return t.map((function(t){return t.transform(e)}))}))),t},_toPlanePolygons:function(e){e=Object.assign({},{flipped:!1},e);let{flipped:t}=e,n=[0,0,0],i=[0,0,1],o=[0,1,0],s=new r(n,i,o),l=e.translation||n,a=e.axisVector||i,u=e.normalVector||o,h=e.toConnector||new r(l,a,u),c=s.getTransformationTo(h,!1,0),p=this.getBounds();p[0]=p[0].minus(new K(1,1)),p[1]=p[1].plus(new K(1,1));let m=this._toCSGWall(-1,1),d=f([new U([new Q(new J(p[0].x,p[0].y,0)),new Q(new J(p[1].x,p[0].y,0)),new Q(new J(p[1].x,p[1].y,0)),new Q(new J(p[0].x,p[1].y,0))])]);return t&&(d=d.invert()),d=d.intersectSub(m),d.polygons.filter((function(e){return Math.abs(e.plane.normal.z)>.99})).map((function(e){return e.transform(c)}))},_toWallPolygons:function(e){let t=new r([0,0,0],[0,0,1],[0,1,0]),n=e.toConnector1,i=e.toConnector2;if(!(n instanceof r&&i instanceof r))throw new Error("could not parse Connector arguments toConnector1 or toConnector2");if(e.cag&&e.cag.sides.length!==this.sides.length)throw new Error("target cag needs same sides count as start cag");let o=e.cag||this,s=t.getTransformationTo(n,!1,0),l=t.getTransformationTo(i,!1,0),a=this._toVector3DPairs(s),u=o._toVector3DPairs(l),h=[];return a.forEach((function(e,t){h.push(new U([new Q(u[t][1]),new Q(u[t][0]),new Q(e[0])])),h.push(new U([new Q(u[t][1]),new Q(e[0]),new Q(e[1])]))})),h},toPoints:function(){let e=this.sides.map((function(e){return e.vertex0.pos}));return e.length>0&&e.push(e.shift()),e},toCompactBinary:function(){let e=this.canonicalized(),t=e.sides.length,n={},r=[],i=0,o=new Uint32Array(2*t),s=0;e.sides.map((function(e){[e.vertex0,e.vertex1].map((function(e){let t,l=e.getTag();l in n?t=n[l]:(t=i++,n[l]=t,r.push(e)),o[s++]=t}))}));let l=new Float64Array(2*i),a=0;return r.map((function(e){let t=e.pos;l[a++]=t._x,l[a++]=t._y})),{class:"CAG",sideVertexIndices:o,vertexData:l}}};let o=function(){this.polygons=[],this.properties=new u,this.isCanonicalized=!0,this.isRetesselated=!0};o.prototype={union:function(e){let t,n;for(e instanceof Array?(t=e.slice(0),t.push(this)):t=[this,e],n=1;n<t.length;n+=2)t.push(t[n-1].unionSub(t[n]));return t[n-1].reTesselated().canonicalized()},unionSub:function(e,t,n){if(this.mayOverlap(e)){let r=new c(this.polygons),i=new c(e.polygons);r.clipTo(i,!1),i.clipTo(r),i.invert(),i.clipTo(r),i.invert();let o=r.allPolygons().concat(i.allPolygons()),s=f(o);return s.properties=this.properties._merge(e.properties),t&&(s=s.reTesselated()),n&&(s=s.canonicalized()),s}return this.unionForNonIntersecting(e)},unionForNonIntersecting:function(e){let t=this.polygons.concat(e.polygons),n=f(t);return n.properties=this.properties._merge(e.properties),n.isCanonicalized=this.isCanonicalized&&e.isCanonicalized,n.isRetesselated=this.isRetesselated&&e.isRetesselated,n},subtract:function(e){let t;t=e instanceof Array?e:[e];let n=this;for(let e=0;e<t.length;e++){let r=e===t.length-1;n=n.subtractSub(t[e],r,r)}return n},subtractSub:function(e,t,n){let r=new c(this.polygons),i=new c(e.polygons);r.invert(),r.clipTo(i),i.clipTo(r,!0),r.addPolygons(i.allPolygons()),r.invert();let o=f(r.allPolygons());return o.properties=this.properties._merge(e.properties),t&&(o=o.reTesselated()),n&&(o=o.canonicalized()),o},intersect:function(e){let t;t=e instanceof Array?e:[e];let n=this;for(let e=0;e<t.length;e++){let r=e===t.length-1;n=n.intersectSub(t[e],r,r)}return n},intersectSub:function(e,t,n){let r=new c(this.polygons),i=new c(e.polygons);r.invert(),i.clipTo(r),i.invert(),r.clipTo(i),i.clipTo(r),r.addPolygons(i.allPolygons()),r.invert();let o=f(r.allPolygons());return o.properties=this.properties._merge(e.properties),t&&(o=o.reTesselated()),n&&(o=o.canonicalized()),o},invert:function(){let e=this.polygons.map((function(e){return e.flipped()}));return f(e)},transform1:function(e){let t=this.polygons.map((function(t){return t.transform(e)})),n=f(t);return n.properties=this.properties._transform(e),n.isRetesselated=this.isRetesselated,n},transform:function(e){let t=e.isMirroring(),n={},r={},i=this.polygons.map((function(i){let o,s=i.plane,l=s.getTag();l in r?o=r[l]:(o=s.transform(e),r[l]=o);let a=i.vertices.map((function(t){let r,i=t.getTag();return i in n?r=n[i]:(r=t.transform(e),n[i]=r),r}));return t&&a.reverse(),new U(a,i.shared,o)})),o=f(i);return o.properties=this.properties._transform(e),o.isRetesselated=this.isRetesselated,o.isCanonicalized=this.isCanonicalized,o},center:function(e){return Ve({axes:e},[this])},expand:function(e,t){return de(this,e,t)},contract:function(e,t){return ge(this,e,t)},expandedShell:function(e,t,n){return ye(this,e,t,n)},stretchAtPlane:function(e,t,n){let r=L.fromNormalAndPoint(e,t),i=new Y(r),o=this.sectionCut(i).extrudeInOrthonormalBasis(i,n),s=this.cutByPlane(r),l=this.cutByPlane(r.flipped());return s.union([o,l.translate(r.normal.times(n))])},canonicalized:function(){return v(this)},reTesselated:function(){return C(this)},fixTJunctions:function(){return E(f,this)},getBounds:function(){return e(this)},mayOverlap:function(t){if(0===this.polygons.length||0===t.polygons.length)return!1;{let n=e(this),r=e(t);return!(n[1].x<r[0].x)&&(!(n[0].x>r[1].x)&&(!(n[1].y<r[0].y)&&(!(n[0].y>r[1].y)&&(!(n[1].z<r[0].z)&&!(n[0].z>r[1].z)))))}},cutByPlane:function(e){return Ie(this,e)},connectTo:function(e,t,n,r){let i=e.getTransformationTo(t,n,r);return this.transform(i)},setShared:function(e){let t=this.polygons.map((function(t){return new U(t.vertices,e,t.plane)})),n=f(t);return n.properties=this.properties,n.isRetesselated=this.isRetesselated,n.isCanonicalized=this.isCanonicalized,n},setColor:function(e){let t=U.Shared.fromColor.apply(this,arguments);return this.setShared(t)},getTransformationAndInverseTransformationToFlatLying:function(){return Pe(this)},getTransformationToFlatLying:function(){return Te(this)},lieFlat:function(){return Se(this)},projectToOrthoNormalBasis:function(e){return S(this,e)},sectionCut:function(e){return Fe(this,e)},getFeatures:function(e){e instanceof Array||(e=[e]);let t=this.toTriangles().map((function(t){return t.getTetraFeatures(e)})).reduce((function(e,t){return t.map((function(t,n){return t+(0===e?0:e[n])}))}),0);return 1===t.length?t[0]:t},toPolygons:function(){return this.polygons},toString:function(){let e="CSG solid:\n";return this.polygons.map((function(t){e+=t.toString()})),e},toCompactBinary:function(){let e=this.canonicalized(),t=e.polygons.length,n=0,r=0,i={},o=[],s=0,l={},a=[],u=[],h={},c=0;e.polygons.map((function(e){e.vertices.map((function(e){++n;let t=e.getTag();t in i||(i[t]=r++,o.push(e))}));let t=e.plane.getTag();t in l||(l[t]=s++,a.push(e.plane));let p=e.shared.getTag();p in h||(h[p]=c++,u.push(e.shared))}));let p=new Uint32Array(t),f=new Uint32Array(t),m=new Uint32Array(n),d=new Uint32Array(t),g=new Float64Array(3*r),w=new Float64Array(4*s),y=0;for(let n=0;n<t;++n){let t=e.polygons[n];p[n]=t.vertices.length,t.vertices.map((function(e){let t=e.getTag(),n=i[t];m[y++]=n}));let r=t.plane.getTag(),o=l[r];d[n]=o;let s=t.shared.getTag(),a=h[s];f[n]=a}let x=0;o.map((function(e){const t=e.pos;g[x++]=t._x,g[x++]=t._y,g[x++]=t._z}));let v=0;return a.map((function(e){const t=e.normal;w[v++]=t._x,w[v++]=t._y,w[v++]=t._z,w[v++]=e.w})),{class:"CSG",numPolygons:t,numVerticesPerPolygon:p,polygonPlaneIndexes:d,polygonSharedIndexes:f,polygonVertices:m,vertexData:g,planeData:w,shared:u}},toTriangles:function(){let e=[];return this.polygons.forEach((function(t){let n=t.vertices[0];for(let r=t.vertices.length-3;r>=0;r--)e.push(new U([n,t.vertices[r+1],t.vertices[r+2]],t.shared,t.plane))})),e}};const s=function(){this.vertexfactory=new a(2,t.EPS)};s.prototype={getVertex:function(e){let t=[e.pos._x,e.pos._y];return this.vertexfactory.lookupOrCreate(t,(function(t){return e}))},getSide:function(e){let t=this.getVertex(e.vertex0),n=this.getVertex(e.vertex1);return new H(t,n)}};const l=function(){this.vertexfactory=new a(3,t.EPS),this.planefactory=new a(4,t.EPS),this.polygonsharedfactory={}};l.prototype={getPolygonShared:function(e){let t=e.getHash();return t in this.polygonsharedfactory?this.polygonsharedfactory[t]:(this.polygonsharedfactory[t]=e,e)},getVertex:function(e){let t=[e.pos._x,e.pos._y,e.pos._z];return this.vertexfactory.lookupOrCreate(t,(function(t){return e}))},getPlane:function(e){let t=[e.normal._x,e.normal._y,e.normal._z,e.w];return this.planefactory.lookupOrCreate(t,(function(t){return e}))},getPolygon:function(e){let t=this.getPlane(e.plane),n=this.getPolygonShared(e.shared),r=this,i=e.vertices.map((function(e){return r.getVertex(e)})),o=[];if(i.length>0){let e=i[i.length-1].getTag();i.forEach((function(t){let n=t.getTag();n!==e&&o.push(t),e=n}))}return o.length<3&&(o=[]),new U(o,n,t)}};const a=function(e,t){this.lookuptable={},this.multiplier=1/t};a.prototype={lookupOrCreate:function(e,t){let n="",r=this.multiplier;if(e.forEach((function(e){let t=Math.round(e*r);n+=t+"/"})),n in this.lookuptable)return this.lookuptable[n];{let i=t(e),o=e.map((function(e){let t=Math.floor(e*r);return[t+"/",t+1+"/"]})),s=1<<e.length;for(let e=0;e<s;++e){let t=e;n="",o.forEach((function(e){n+=e[1&t],t>>=1})),this.lookuptable[n]=i}return i}}};const u=function(){};u.prototype={_transform:function(e){let t=new u;return u.transformObj(this,t,e),t},_merge:function(e){let t=new u;return u.cloneObj(this,t),u.addFrom(t,e),t}},u.transformObj=function(e,t,n){for(let r in e){if("_transform"===r)continue;if("_merge"===r)continue;let i=e[r],o=i;"object"==typeof i&&("transform"in i&&"function"==typeof i.transform?o=i.transform(n):i instanceof Array?(o=[],u.transformObj(i,o,n)):i instanceof u&&(o=new u,u.transformObj(i,o,n))),t[r]=o}},u.cloneObj=function(e,t){for(let n in e){if("_transform"===n)continue;if("_merge"===n)continue;let r=e[n],i=r;if("object"==typeof r)if(r instanceof Array){i=[];for(let e=0;e<r.length;e++)i.push(r[e])}else r instanceof u&&(i=new u,u.cloneObj(r,i));t[n]=i}},u.addFrom=function(e,t){for(let n in t)"_transform"!==n&&"_merge"!==n&&(n in e&&"object"==typeof e[n]&&e[n]instanceof u&&"object"==typeof t[n]&&t[n]instanceof u?u.addFrom(e[n],t[n]):n in e||(e[n]=t[n]))};const h=function(){this.parent=null,this.children=[],this.polygon=null,this.removed=!1};h.prototype={addPolygons:function(e){if(!this.isRootNode())throw new Error("Assertion failed");let t=this;e.map((function(e){t.addChild(e)}))},remove:function(){if(!this.removed){if(this.removed=!0,t._CSGDEBUG){if(this.isRootNode())throw new Error("Assertion failed");if(this.children.length)throw new Error("Assertion failed")}let e=this.parent.children,n=e.indexOf(this);if(n<0)throw new Error("Assertion failed");e.splice(n,1),this.parent.recursivelyInvalidatePolygon()}},isRemoved:function(){return this.removed},isRootNode:function(){return!this.parent},invert:function(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()},getPolygon:function(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon},getPolygons:function(e){let t,n,r,i,o=[this],s=[o];for(t=0;t<s.length;++t)for(o=s[t],n=0,r=o.length;n<r;n++)i=o[n],i.polygon?e.push(i.polygon):s.push(i.children)},splitByPlane:function(e,t,n,r,i){if(this.children.length){let o,s,l,a,u,h=[this.children];for(o=0;o<h.length;o++)for(u=h[o],s=0,l=u.length;s<l;s++)a=u[s],a.children.length?h.push(a.children):a._splitByPlane(e,t,n,r,i)}else this._splitByPlane(e,t,n,r,i)},_splitByPlane:function(e,n,r,i,o){let s=this.polygon;if(s){let l=s.boundingSphere(),a=l[1]+t.EPS,u=e.normal,h=l[0],c=u.dot(h)-e.w;if(c>a)i.push(this);else if(c<-a)o.push(this);else{let l=function(e,n){let r={type:null,front:null,back:null},i=e.normal,o=n.vertices,s=o.length;if(n.plane.equals(e))r.type=0;else{let l=e.w,a=!1,u=!1,h=[],c=-t.EPS;for(let e=0;e<s;e++){let n=i.dot(o[e].pos)-l,r=n<0;h.push(r),n>t.EPS&&(a=!0),n<c&&(u=!0)}if(a||u)if(u)if(a){r.type=4;let i=[],l=[],a=h[0];for(let t=0;t<s;t++){let n=o[t],r=t+1;r>=s&&(r=0);let u=h[r];if(a===u)a?l.push(n):i.push(n);else{let t=n.pos,s=o[r].pos,u=e.splitLineBetweenPoints(t,s),h=new Q(u);a?(l.push(n),l.push(h),i.push(h)):(i.push(n),i.push(h),l.push(h))}a=u}let u=t.EPS*t.EPS;if(l.length>=3){let e=l[l.length-1];for(let t=0;t<l.length;t++){let n=l[t];n.pos.distanceToSquared(e.pos)<u&&(l.splice(t,1),t--),e=n}}if(i.length>=3){let e=i[i.length-1];for(let t=0;t<i.length;t++){let n=i[t];n.pos.distanceToSquared(e.pos)<u&&(i.splice(t,1),t--),e=n}}i.length>=3&&(r.front=new U(i,n.shared,n.plane)),l.length>=3&&(r.back=new U(l,n.shared,n.plane))}else r.type=3;else r.type=2;else{let e=i.dot(n.plane.normal);r.type=e>=0?0:1}}return r}(e,s);switch(l.type){case 0:n.push(this);break;case 1:r.push(this);break;case 2:i.push(this);break;case 3:o.push(this);break;case 4:if(l.front){let e=this.addChild(l.front);i.push(e)}if(l.back){let e=this.addChild(l.back);o.push(e)}}}}},addChild:function(e){let t=new h;return t.parent=this,t.polygon=e,this.children.push(t),t},invertSub:function(){let e,t,n,r,i=[this],o=[i];for(e=0;e<o.length;e++)for(i=o[e],t=0,n=i.length;t<n;t++)r=i[t],r.polygon&&(r.polygon=r.polygon.flipped()),o.push(r.children)},recursivelyInvalidatePolygon:function(){let e=this;for(;e.polygon;)e.polygon=null,e.parent&&(e=e.parent)}};const c=function(e){this.polygonTree=new h,this.rootnode=new p(null),e&&this.addPolygons(e)};c.prototype={invert:function(){this.polygonTree.invert(),this.rootnode.invert()},clipTo:function(e,t){t=!!t,this.rootnode.clipTo(e,t)},allPolygons:function(){let e=[];return this.polygonTree.getPolygons(e),e},addPolygons:function(e){let t=this,n=e.map((function(e){return t.polygonTree.addChild(e)}));this.rootnode.addPolygonTreeNodes(n)}};const p=function(e){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=e};p.prototype={invert:function(){let e,t=[this];for(let n=0;n<t.length;n++){e=t[n],e.plane&&(e.plane=e.plane.flipped()),e.front&&t.push(e.front),e.back&&t.push(e.back);let r=e.front;e.front=e.back,e.back=r}},clipPolygons:function(e,t){let n,r={node:this,polygontreenodes:e},i=[];do{if(n=r.node,e=r.polygontreenodes,n.plane){let r=[],o=[],s=t?r:o,l=n.plane,a=e.length;for(let t=0;t<a;t++){let n=e[t];n.isRemoved()||n.splitByPlane(l,s,r,o,r)}n.front&&o.length>0&&i.push({node:n.front,polygontreenodes:o});let u=r.length;if(n.back&&u>0)i.push({node:n.back,polygontreenodes:r});else for(let e=0;e<u;e++)r[e].remove()}r=i.pop()}while(void 0!==r)},clipTo:function(e,t){let n=this,r=[];do{n.polygontreenodes.length>0&&e.rootnode.clipPolygons(n.polygontreenodes,t),n.front&&r.push(n.front),n.back&&r.push(n.back),n=r.pop()}while(void 0!==n)},addPolygonTreeNodes:function(e){let t,n={node:this,polygontreenodes:e},r=[];do{if(t=n.node,0===(e=n.polygontreenodes).length){n=r.pop();continue}let i=t;if(!t.plane){let n=e[0].getPolygon().plane;t.plane=n}let o=[],s=[];for(let t=0,n=e.length;t<n;++t)e[t].splitByPlane(i.plane,i.polygontreenodes,s,o,s);o.length>0&&(t.front||(t.front=new p(t)),r.push({node:t.front,polygontreenodes:o})),s.length>0&&(t.back||(t.back=new p(t)),r.push({node:t.back,polygontreenodes:s})),n=r.pop()}while(void 0!==n)},getParentPlaneNormals:function(e,t){t>0&&this.parent&&(e.push(this.parent.plane.normal),this.parent.getParentPlaneNormals(e,t-1))}};const f=function(e){let t=new o;return t.polygons=e,t.isCanonicalized=!1,t.isRetesselated=!1,t},m=function(e){let t=new i;return t.sides=e,t},d=function(e){let t=e.polygons.map((function(e){return H._fromFakePolygon(e)})).filter((function(e){return null!==e}));return m(t)},g=function(e){if(!e)throw new Error("points parameter must be defined");if(!Array.isArray(e))throw new Error("points parameter must be an array");if(void 0!==e[0].x||"number"==typeof e[0][0])return w(e);if("object"==typeof e[0][0])return y(e);throw new Error("Unsupported points list format")},w=function(e){if(e.length<3)throw new Error("CAG shape needs at least 3 points");let n=[],r=new $(new K(e[e.length-1]));e.map((function(e){let t=new $(new K(e));n.push(new H(r,t)),r=t}));let i=m(n);if(R(i))throw new Error("Polygon is self intersecting!");let o=i.area();if(Math.abs(o)<t.areaEPS)throw new Error("Degenerate polygon!");return o<0&&(i=i.flipped()),i.canonicalized()},y=function(e){if(1===e.length)return g(e[0]);let t=[];e.forEach(e=>{t.push(w(e))});let n={};t.forEach((e,r)=>{t.forEach((t,i)=>{e!==t&&(n[r]||(n[r]={parents:[],isHole:!1}),n[i]||(n[i]={parents:[],isHole:!1}),O(t,e)&&(n[r].parents.push(i),n[r].isHole=!!(n[r].parents.length%2),n[i].isHole=!!(n[i].parents.length%2)))})});let r=null;for(key in n)r=n[key],r.isHole&&(delete n[key],r.parents.forEach(e=>{t[e]=Ne(t[e],t[key])}));let i=m([]);for(key in n)i=qe(i,t[key]);return i},x=function(e){let t=[],n=new K(e[e.length-1]),r=new $(n);return e.map((function(e){let n=new K(e),i=new $(n),o=new H(r,i);t.push(o),r=i})),m(t)},v=function(e,t){return e.isCanonicalized?e:"sides"in e?b(e):_(e)},_=function(e,t){if(e.isCanonicalized)return e;{const t=new l;let n=P(t,e);return n.isCanonicalized=!0,n.isRetesselated=e.isRetesselated,n.properties=e.properties,n}},b=function(e,t){if(e.isCanonicalized)return e;{let t=new s,n=T(t,e);return n.isCanonicalized=!0,n}},P=function(e,t){let n=e,r=[];return t.polygons.forEach((function(e){let t=n.getPolygon(e);t.vertices.length>=3&&r.push(t)})),f(r)},T=function(e,n){let r=e,i=n.sides.map((function(e){return r.getSide(e)})).filter((function(e){return e.length()>t.EPS}));return m(i)},S=function(e,n){let r=[];return e.polygons.filter((function(e){return e.plane.normal.minus(n.plane.normal).lengthSquared()<t.EPS*t.EPS})).map((function(e){let t=e.projectToOrthoNormalBasis(n);t.sides.length>0&&r.push(t)})),(new i).union(r)};function M(e,t,n,r,i,o){let s=r.getTag(),l=i.getTag();if(s===l)throw new Error("Assertion failed");let a=s+"/"+l;if(l+"/"+s in e)return z(e,t,n,i,r,null),null;let u={vertex0:r,vertex1:i,polygonindex:o};return a in e?e[a].push(u):e[a]=[u],s in t?t[s].push(a):t[s]=[a],l in n?n[l].push(a):n[l]=[a],a}function z(e,t,n,r,i,o){let s=r.getTag(),l=i.getTag(),a=s+"/"+l;if(!(a in e))throw new Error("Assertion failed");let u=-1,h=e[a];for(let e=0;e<h.length;e++){let t=h[e];if(t.vertex0===r&&(t.vertex1===i&&(null===o||t.polygonindex===o))){u=e;break}}if(u<0)throw new Error("Assertion failed");if(h.splice(u,1),0===h.length&&delete e[a],u=t[s].indexOf(a),u<0)throw new Error("Assertion failed");if(t[s].splice(u,1),0===t[s].length&&delete t[s],u=n[l].indexOf(a),u<0)throw new Error("Assertion failed");n[l].splice(u,1),0===n[l].length&&delete n[l]}const E=function(e,n){n=n.canonicalized();let r={};for(let e=0;e<n.polygons.length;e++){let t=n.polygons[e],i=t.vertices.length;if(i>=3){let n=t.vertices[0],o=n.getTag();for(let s=0;s<i;s++){let l=s+1;l===i&&(l=0);let a=t.vertices[l],u=a.getTag(),h=o+"/"+u,c=u+"/"+o;if(c in r){let e=r[c];e.splice(-1,1),0===e.length&&delete r[c]}else{let t={vertex0:n,vertex1:a,polygonindex:e};h in r?r[h].push(t):r[h]=[t]}n=a,o=u}}}let i={},o={},s={},l=!0;for(let e in r)l=!1,s[e]=!0,r[e].map((function(t){let n=t.vertex0.getTag(),r=t.vertex1.getTag();n in i?i[n].push(e):i[n]=[e],r in o?o[r].push(e):o[r]=[e]}));if(!l){let l=n.polygons.slice(0);for(;;){let e=!0;for(let t in r)e=!1,s[t]=!0;if(e)break;let n=!1;for(;;){let e=null;for(let t in s){e=t;break}if(null===e)break;let a=!0;if(e in r){let u=r[e];if(0===u.length)throw new Error("Assertion failed");let h=u[0];for(let e=0;e<2;e++){let u=0===e?h.vertex0:h.vertex1,c=0===e?h.vertex1:h.vertex0,p=u.getTag(),f=c.getTag(),m=[];0===e?p in o&&(m=o[p]):p in i&&(m=i[p]);for(let h=0;h<m.length;h++){let d=r[m[h]][0],g=0===e?d.vertex0:d.vertex1,w=0===e?d.vertex1:d.vertex0,y=g.getTag();if(w.getTag()!==p)throw new Error("Assertion failed");if(y===f){z(r,i,o,u,c,null),z(r,i,o,c,u,null),a=!1,e=2,n=!0;break}{let h=u.pos,p=c.pos,f=g.pos.minus(h),m=p.minus(h).dot(f)/f.dot(f);if(m>0&&m<1){if(h.plus(f.times(m)).distanceToSquared(p)<t.EPS*t.EPS){let t=d.polygonindex,u=l[t],h=d.vertex1.getTag(),p=-1;for(let e=0;e<u.vertices.length;e++)if(u.vertices[e].getTag()===h){p=e;break}if(p<0)throw new Error("Assertion failed");let f=u.vertices.slice(0);f.splice(p,0,c);let m=new U(f,u.shared);if(isNaN(m.plane.w)){let e=!1,t=function(t){m.vertices.forEach((function(n){e||t(n)}))};t((function(n){t((function(r){t((function(t){m.plane=L.fromPoints(n.pos,r.pos,t.pos),isNaN(m.plane.w)||(e=!0)}))}))}))}l[t]=m,z(r,i,o,d.vertex0,d.vertex1,t);let g=M(r,i,o,d.vertex0,c,t),w=M(r,i,o,c,d.vertex1,t);null!==g&&(s[g]=!0),null!==w&&(s[w]=!0),a=!1,e=2,n=!0;break}}}}}}a&&delete s[e]}if(!n)break}let a=e(l);a.properties=n.properties,a.isCanonicalized=!0,a.isRetesselated=!0,n=a}return n},C=function(e){if(e.isRetesselated)return e;{let t={},n=e.isCanonicalized,r=new l;e.polygons.map((function(e){let i=e.plane,o=e.shared;n||(i=r.getPlane(i),o=r.getPolygonShared(o));let s=i.getTag()+"/"+o.getTag();s in t?t[s].push(e):t[s]=[e]}));let i=[];for(let e in t){let n=t[e];if(n.length<2)i=i.concat(n);else{let e=[];te(n,e),i=i.concat(e)}}let o=f(i);return o.isRetesselated=!0,o.properties=e.properties,o}};function k(e,t){return e-t}function A(e,t){return e.index-t.index}const D=function(e){return!isNaN(e)||e===1/0||e===-1/0},B=function(e,t,n,r,i,o){let s=1/(e*r-t*n),l=i*r-t*o,a=-i*n+e*o;return l*=s,a*=s,[l,a]};function F(e,t,n){let r=0,i=e.length;for(;i>r;){let o=Math.floor((r+i)/2);n(t,e[o])>0?r=o+1:i=o}e.splice(r,0,t)}const I=function(e,t,n){let r,i=n-e.y,o=t.y-e.y;return o<0&&(i=-i,o=-o),r=i<=0?0:i>=o?1:o<1e-10?.5:i/o,e.x+r*(t.x-e.x)};function V(e){return"sides"in e&&"length"in e.sides}function q(e){return"polygons"in e&&"length"in e.polygons}const N=function(e){let n=[];e.isSelfIntersecting(!0)&&n.push("Self intersects");let r={};e.sides.map((function(e){function t(e){let t=e.x+" "+e.y;t in r||(r[t]=0),r[t]++}t(e.vertex0.pos),t(e.vertex1.pos)}));for(let e in r){let t=r[e];1&t&&n.push("Uneven number of sides ("+t+") for point "+e)}let i=e.area();if(i<t.areaEPS&&n.push("Area is "+i),n.length>0){let e="";throw n.map((function(t){e+=t+"\n"})),new Error(e)}},R=function(e,t){let n=e.sides.length;for(let r=0;r<n;r++){let i=e.sides[r];for(let o=r+1;o<n;o++){let n=e.sides[o];if(ee(i.vertex0.pos,i.vertex1.pos,n.vertex0.pos,n.vertex1.pos))return t&&(console.log("side "+r+": "+i),console.log("side "+o+": "+n)),!0}}return!1},j=function(e,t){let n=null,r=null,i=!1;return e.sides.forEach(e=>{n=e.vertex0.pos,r=e.vertex1.pos,j.c1(t,n,r)&&j.c2(t,n,r)&&(i=!i)}),i};j.c1=(e,t,n)=>t.y>e.y!=n.y>e.y,j.c2=(e,t,n)=>e.x<(n.x-t.x)*(e.y-t.y)/(n.y-t.y)+t.x;const O=function(e,t){for(let n=0,r=t.sides.length;n<r;n++)if(!j(e,t.sides[n].vertex0.pos))return!1;return!0},Z=function(e,t){e=new K(e),t=parseFloat(t);let n=e.length();t*=n,e=e.times(1/n),this.normal=e,this.w=t};Z.fromPoints=function(e,t){e=new K(e);let n=(t=new K(t)).minus(e).normal().negated().unit(),r=e.dot(n);return new Z(n,r)},Z.prototype={reverse:function(){return new Z(this.normal.negated(),-this.w)},equals:function(e){return e.normal.equals(this.normal)&&e.w===this.w},origin:function(){return this.normal.times(this.w)},direction:function(){return this.normal.normal()},xAtY:function(e){return(this.w-this.normal._y*e)/this.normal.x},absDistanceToPoint:function(e){let t=(e=new K(e)).dot(this.normal);return Math.abs(t-this.w)},intersectWithLine:function(e){let t=B(this.normal.x,this.normal.y,e.normal.x,e.normal.y,this.w,e.w);return t=new K(t),t},transform:function(e){let t=new K(0,0),n=this.normal.times(this.w),r=t.multiply4x4(e),i=this.normal.multiply4x4(e).minus(r),o=n.multiply4x4(e),s=i.dot(o);return new Z(i,s)}};const G=function(e,t){e=new J(e),t=new J(t),this.point=e,this.direction=t.unit()};G.fromPoints=function(e,t){e=new J(e);let n=(t=new J(t)).minus(e);return new G(e,n)},G.fromPlanes=function(e,n){let r=e.normal.cross(n.normal),i=r.length();if(i<t.EPS)throw new Error("Parallel planes");r=r.times(1/i);let o,s=Math.abs(r.x),l=Math.abs(r.y),a=Math.abs(r.z);if(s>=l&&s>=a){let t=B(e.normal.y,e.normal.z,n.normal.y,n.normal.z,e.w,n.w);o=new J(0,t[0],t[1])}else if(l>=s&&l>=a){let t=B(e.normal.x,e.normal.z,n.normal.x,n.normal.z,e.w,n.w);o=new J(t[0],0,t[1])}else{let t=B(e.normal.x,e.normal.y,n.normal.x,n.normal.y,e.w,n.w);o=new J(t[0],t[1],0)}return new G(o,r)},G.prototype={intersectWithPlane:function(e){let t=(e.w-e.normal.dot(this.point))/e.normal.dot(this.direction);return this.point.plus(this.direction.times(t))},clone:function(e){return new G(this.point.clone(),this.direction.clone())},reverse:function(){return new G(this.point.clone(),this.direction.negated())},transform:function(e){let t=this.point.multiply4x4(e),n=this.point.plus(this.direction).multiply4x4(e).minus(t);return new G(t,n)},closestPointOnLine:function(e){let t=(e=new J(e)).minus(this.point).dot(this.direction)/this.direction.dot(this.direction);return this.point.plus(this.direction.times(t))},distanceToPoint:function(e){e=new J(e);let t=this.closestPointOnLine(e);return e.minus(t).length()},equals:function(e){if(!this.direction.equals(e.direction))return!1;return!(this.distanceToPoint(e.point)>t.EPS)}};const X=function(e){this.elements=arguments.length>=1?e:[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]};X.prototype={plus:function(e){for(var t=[],n=0;n<16;n++)t[n]=this.elements[n]+e.elements[n];return new X(t)},minus:function(e){for(var t=[],n=0;n<16;n++)t[n]=this.elements[n]-e.elements[n];return new X(t)},multiply:function(e){var t=this.elements[0],n=this.elements[1],r=this.elements[2],i=this.elements[3],o=this.elements[4],s=this.elements[5],l=this.elements[6],a=this.elements[7],u=this.elements[8],h=this.elements[9],c=this.elements[10],p=this.elements[11],f=this.elements[12],m=this.elements[13],d=this.elements[14],g=this.elements[15],w=e.elements[0],y=e.elements[1],x=e.elements[2],v=e.elements[3],_=e.elements[4],b=e.elements[5],P=e.elements[6],T=e.elements[7],S=e.elements[8],M=e.elements[9],z=e.elements[10],E=e.elements[11],C=e.elements[12],k=e.elements[13],A=e.elements[14],D=e.elements[15],B=[];return B[0]=t*w+n*_+r*S+i*C,B[1]=t*y+n*b+r*M+i*k,B[2]=t*x+n*P+r*z+i*A,B[3]=t*v+n*T+r*E+i*D,B[4]=o*w+s*_+l*S+a*C,B[5]=o*y+s*b+l*M+a*k,B[6]=o*x+s*P+l*z+a*A,B[7]=o*v+s*T+l*E+a*D,B[8]=u*w+h*_+c*S+p*C,B[9]=u*y+h*b+c*M+p*k,B[10]=u*x+h*P+c*z+p*A,B[11]=u*v+h*T+c*E+p*D,B[12]=f*w+m*_+d*S+g*C,B[13]=f*y+m*b+d*M+g*k,B[14]=f*x+m*P+d*z+g*A,B[15]=f*v+m*T+d*E+g*D,new X(B)},clone:function(){var e=this.elements.map((function(e){return e}));return new X(e)},rightMultiply1x3Vector:function(e){var t=e._x,n=e._y,r=e._z,i=t*this.elements[0]+n*this.elements[1]+r*this.elements[2]+1*this.elements[3],o=t*this.elements[4]+n*this.elements[5]+r*this.elements[6]+1*this.elements[7],s=t*this.elements[8]+n*this.elements[9]+r*this.elements[10]+1*this.elements[11],l=t*this.elements[12]+n*this.elements[13]+r*this.elements[14]+1*this.elements[15];if(1!==l){var a=1/l;i*=a,o*=a,s*=a}return new J(i,o,s)},leftMultiply1x3Vector:function(e){var t=e._x,n=e._y,r=e._z,i=t*this.elements[0]+n*this.elements[4]+r*this.elements[8]+1*this.elements[12],o=t*this.elements[1]+n*this.elements[5]+r*this.elements[9]+1*this.elements[13],s=t*this.elements[2]+n*this.elements[6]+r*this.elements[10]+1*this.elements[14],l=t*this.elements[3]+n*this.elements[7]+r*this.elements[11]+1*this.elements[15];if(1!==l){var a=1/l;i*=a,o*=a,s*=a}return new J(i,o,s)},rightMultiply1x2Vector:function(e){var t=e.x,n=e.y,r=t*this.elements[0]+n*this.elements[1]+0*this.elements[2]+1*this.elements[3],i=t*this.elements[4]+n*this.elements[5]+0*this.elements[6]+1*this.elements[7],o=(this.elements[8],this.elements[9],this.elements[10],this.elements[11],t*this.elements[12]+n*this.elements[13]+0*this.elements[14]+1*this.elements[15]);if(1!==o){var s=1/o;r*=s,i*=s,s}return new K(r,i)},leftMultiply1x2Vector:function(e){var t=e.x,n=e.y,r=t*this.elements[0]+n*this.elements[4]+0*this.elements[8]+1*this.elements[12],i=t*this.elements[1]+n*this.elements[5]+0*this.elements[9]+1*this.elements[13],o=(this.elements[2],this.elements[6],this.elements[10],this.elements[14],t*this.elements[3]+n*this.elements[7]+0*this.elements[11]+1*this.elements[15]);if(1!==o){var s=1/o;r*=s,i*=s,s}return new K(r,i)},isMirroring:function(){var e=new J(this.elements[0],this.elements[4],this.elements[8]),t=new J(this.elements[1],this.elements[5],this.elements[9]),n=new J(this.elements[2],this.elements[6],this.elements[10]);return e.cross(t).dot(n)<0}},X.unity=function(){return new X},X.rotationX=function(e){var t=e*Math.PI*(1/180),n=Math.cos(t),r=Math.sin(t);return new X([1,0,0,0,0,n,r,0,0,-r,n,0,0,0,0,1])},X.rotationY=function(e){var t=e*Math.PI*(1/180),n=Math.cos(t),r=Math.sin(t);return new X([n,0,-r,0,0,1,0,0,r,0,n,0,0,0,0,1])},X.rotationZ=function(e){var t=e*Math.PI*(1/180),n=Math.cos(t),r=Math.sin(t);return new X([n,r,0,0,-r,n,0,0,0,0,1,0,0,0,0,1])},X.rotation=function(e,t,n){e=new J(e),t=new J(t);var r=L.fromNormalAndPoint(t,e),i=new Y(r),o=X.translation(e.negated());return o=(o=(o=(o=o.multiply(i.getProjectionMatrix())).multiply(X.rotationZ(n))).multiply(i.getInverseProjectionMatrix())).multiply(X.translation(e))},X.translation=function(e){var t=new J(e),n=[1,0,0,0,0,1,0,0,0,0,1,0,t.x,t.y,t.z,1];return new X(n)},X.mirroring=function(e){var t=e.normal.x,n=e.normal.y,r=e.normal.z,i=e.w;return new X([1-2*t*t,-2*n*t,-2*r*t,0,-2*t*n,1-2*n*n,-2*r*n,0,-2*t*r,-2*n*r,1-2*r*r,0,2*t*i,2*n*i,2*r*i,1])},X.scaling=function(e){var t=new J(e),n=[t.x,0,0,0,0,t.y,0,0,0,0,t.z,0,0,0,0,1];return new X(n)};const Y=function(e,t){t=arguments.length<2?e.normal.randomNonParallelVector():new J(t),this.v=e.normal.cross(t).unit(),this.u=this.v.cross(e.normal),this.plane=e,this.planeorigin=e.normal.times(e.w)};Y.GetCartesian=function(e,t){let n,r,i=e+"/"+t;if("X/Y"===i)n=[0,0,1],r=[1,0,0];else if("Y/-X"===i)n=[0,0,1],r=[0,1,0];else if("-X/-Y"===i)n=[0,0,1],r=[-1,0,0];else if("-Y/X"===i)n=[0,0,1],r=[0,-1,0];else if("-X/Y"===i)n=[0,0,-1],r=[-1,0,0];else if("-Y/-X"===i)n=[0,0,-1],r=[0,-1,0];else if("X/-Y"===i)n=[0,0,-1],r=[1,0,0];else if("Y/X"===i)n=[0,0,-1],r=[0,1,0];else if("X/Z"===i)n=[0,-1,0],r=[1,0,0];else if("Z/-X"===i)n=[0,-1,0],r=[0,0,1];else if("-X/-Z"===i)n=[0,-1,0],r=[-1,0,0];else if("-Z/X"===i)n=[0,-1,0],r=[0,0,-1];else if("-X/Z"===i)n=[0,1,0],r=[-1,0,0];else if("-Z/-X"===i)n=[0,1,0],r=[0,0,-1];else if("X/-Z"===i)n=[0,1,0],r=[1,0,0];else if("Z/X"===i)n=[0,1,0],r=[0,0,1];else if("Y/Z"===i)n=[1,0,0],r=[0,1,0];else if("Z/-Y"===i)n=[1,0,0],r=[0,0,1];else if("-Y/-Z"===i)n=[1,0,0],r=[0,-1,0];else if("-Z/Y"===i)n=[1,0,0],r=[0,0,-1];else if("-Y/Z"===i)n=[-1,0,0],r=[0,-1,0];else if("-Z/-Y"===i)n=[-1,0,0],r=[0,0,-1];else if("Y/-Z"===i)n=[-1,0,0],r=[0,1,0];else{if("Z/Y"!==i)throw new Error("OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");n=[-1,0,0],r=[0,0,1]}return new Y(new L(new J(n),0),new J(r))},Y.Z0Plane=function(){let e=new L(new J([0,0,1]),0);return new Y(e,new J([1,0,0]))},Y.prototype={getProjectionMatrix:function(){return new X([this.u.x,this.v.x,this.plane.normal.x,0,this.u.y,this.v.y,this.plane.normal.y,0,this.u.z,this.v.z,this.plane.normal.z,0,0,0,-this.plane.w,1])},getInverseProjectionMatrix:function(){let e=this.plane.normal.times(this.plane.w);return new X([this.u.x,this.u.y,this.u.z,0,this.v.x,this.v.y,this.v.z,0,this.plane.normal.x,this.plane.normal.y,this.plane.normal.z,0,e.x,e.y,e.z,1])},to2D:function(e){return new K(e.dot(this.u),e.dot(this.v))},to3D:function(e){return this.planeorigin.plus(this.u.times(e.x)).plus(this.v.times(e.y))},line3Dto2D:function(e){let t=e.point,n=e.direction.plus(t),r=this.to2D(t),i=this.to2D(n);return Z.fromPoints(r,i)},line2Dto3D:function(e){let t=e.origin(),n=e.direction().plus(t),r=this.to3D(t),i=this.to3D(n);return G.fromPoints(r,i)},transform:function(e){let t=this.plane.transform(e),n=this.u.transform(e),r=new J(0,0,0).transform(e),i=n.minus(r);return new Y(t,i)}};const W=function(e,n){e=e||[];let r=null;(n=!!n)&&e.length>0&&(r=new K(e[e.length-1]));let i=[];e.map((function(e){e=new K(e);let n=!1;if(null!==r){n=e.distanceTo(r)<t.EPS}n||i.push(e),r=e})),this.points=i,this.closed=n};W.arc=function(e){let n=ke(e,"center",0),r=Ae(e,"radius",1),i=Ae(e,"startangle",0),o=Ae(e,"endangle",360),s=De(e,"resolution",t.defaultResolution2D),l=Be(e,"maketangent",!1);for(;o-i>=720;)o-=360;for(;o-i<=-720;)o+=360;let a,u=[],h=Math.abs(o-i);if(h<t.angleEPS)a=K.fromAngle(i/180*Math.PI).times(r),u.push(a.plus(n));else{let e=Math.floor(s*h/360)+1,t=.5*e/h;t>.25&&(t=.25);let c=l?e+2:e;for(let s=0;s<=c;s++){let h=s;l&&(h=(s-1)*(e-2*t)/e+t,h<0&&(h=0),h>e&&(h=e));let c=i+h*(o-i)/e;a=K.fromAngle(c/180*Math.PI).times(r),u.push(a.plus(n))}}return new W(u,!1)},W.prototype={concat:function(e){if(this.closed||e.closed)throw new Error("Paths must not be closed");let t=this.points.concat(e.points);return new W(t)},getPoints:function(){return this.points},appendPoint:function(e){if(this.closed)throw new Error("Path must not be closed");e=new K(e);let t=this.points.concat([e]);return new W(t)},appendPoints:function(e){if(this.closed)throw new Error("Path must not be closed");let t=this.points;return e.forEach((function(e){t.push(new K(e))})),new W(t)},close:function(){return new W(this.points,!0)},isClosed:function(){return this.closed},getTurn:function(){const e=this.points;let t=0,n=e.length-1;for(let r=0;r<e.length;n=r++)t+=e[n].x*e[r].y-e[n].y*e[r].x;return t>0?"clockwise":t<0?"counter-clockwise":"straight"},rectangularExtrude:function(e,t,n){return this.expandToCAG(e/2,n).extrude({offset:[0,0,t]})},expandToCAG:function(e,t){let n,r=[],o=this.points.length,s=0;this.closed&&o>2&&(s=-1);for(let e=s;e<o;e++){let t=e;t<0&&(t=o-1);let i=this.points[t],l=new Q(i);if(e>s){let e=new H(n,l);r.push(e)}n=l}return i.fromSides(r).expandedShell(e,t)},innerToCAG:function(){if(!this.closed)throw new Error("The path should be closed!");return i.fromPoints(this.points)},transform:function(e){let t=this.points.map((function(t){return t.multiply4x4(e)}));return new W(t,this.closed)},appendBezier:function(e,n){if(arguments.length<2&&(n={}),this.closed)throw new Error("Path must not be closed");if(!(e instanceof Array))throw new Error("appendBezier: should pass an array of control points");if(e.length<1)throw new Error("appendBezier: need at least 1 control point");if(this.points.length<1)throw new Error("appendBezier: path must already contain a point (the endpoint of the path is used as the starting point for the bezier curve)");let r=De(n,"resolution",t.defaultResolution2D);r<4&&(r=4);let i=[],o=[];o.push(this.points[this.points.length-1]);for(let t=0;t<e.length;++t){let n=e[t];if(null===n){if(0!==t)throw new Error("appendBezier: null can only be passed as the first control point");if(e.length<2)throw new Error("appendBezier: null can only be passed if there is at least one more control point");let r;if("lastBezierControlPoint"in this)r=this.lastBezierControlPoint;else{if(this.points.length<2)throw new Error("appendBezier: null is passed as a control point but this requires a previous bezier curve or at least two points in the existing path");r=this.points[this.points.length-2]}n=this.points[this.points.length-1].times(2).minus(r)}else n=new K(n);o.push(n)}let s=o.length-1,l=1;for(let e=0;e<=s;++e)e>0&&(l*=e),i.push(l);let a=[];for(let e=0;e<=s;++e){let t=i[s]/(i[e]*i[s-e]);a.push(t)}let u=function(e){let t=1,n=Math.pow(1-e,s),r=1!==e?1/(1-e):1,i=new K(0,0);for(let l=0;l<=s;++l){l===s&&(n=1);let u=a[l]*t*n;i=i.plus(o[l].times(u)),t*=e,n*=r}return i},h=[],c=[],p=s+1;for(let e=0;e<p;++e){let t=e/(p-1),n=u(t);h.push(n),c.push(t)}let f=1,m=2*Math.PI/r,d=Math.sin(m);for(;f<h.length-1;){let e=h[f].minus(h[f-1]).unit(),t=h[f+1].minus(h[f]).unit(),n=e.cross(t);if(Math.abs(n)>d){let e=c[f-1],t=c[f+1],n=e+1*(t-e)/3,r=e+2*(t-e)/3,i=u(n),o=u(r);h.splice(f,1,i,o),c.splice(f,1,n,r),f--,f<1&&(f=1)}else++f}h=this.points.concat(h.slice(1));let g=new W(h);return g.lastBezierControlPoint=o[o.length-2],g},appendArc:function(e,n){let r=1e5;if(arguments.length<2&&(n={}),this.closed)throw new Error("Path must not be closed");if(this.points.length<1)throw new Error("appendArc: path must already contain a point (the endpoint of the path is used as the starting point for the arc)");let i,o,s=De(n,"resolution",t.defaultResolution2D);if(s<4&&(s=4),"xradius"in n||"yradius"in n){if("radius"in n)throw new Error("Should either give an xradius and yradius parameter, or a radius parameter");i=Ae(n,"xradius",0),o=Ae(n,"yradius",0)}else i=Ae(n,"radius",0),o=i;let l=Ae(n,"xaxisrotation",0),a=Be(n,"clockwise",!1),u=Be(n,"large",!1),h=this.points[this.points.length-1];e=new K(e),i=Math.round(i*r)/r,o=Math.round(o*r)/r,e=new K(Math.round(e.x*r)/r,Math.round(e.y*r)/r);let c=!a,p=[];if(0===i||0===o)p.push(e);else{i=Math.abs(i),o=Math.abs(o);let t=l*Math.PI/180,n=Math.cos(t),a=Math.sin(t),f=h.minus(e).times(.5),m=Math.round((n*f.x+a*f.y)*r)/r,d=Math.round((-a*f.x+n*f.y)*r)/r,g=new K(m,d),w=g.x*g.x/(i*i)+g.y*g.y/(o*o);if(w>1){let e=Math.sqrt(w);i*=e,o*=e,i=Math.round(i*r)/r,o=Math.round(o*r)/r}let y=Math.sqrt((i*i*o*o-i*i*g.y*g.y-o*o*g.x*g.x)/(i*i*g.y*g.y+o*o*g.x*g.x));c===u&&(y=-y);let x=new K(i*g.y/o,-o*g.x/i).times(y),v=new K(n*x.x-a*x.y,a*x.x+n*x.y).plus(h.plus(e).times(.5)),_=new K((g.x-x.x)/i,(g.y-x.y)/o),b=new K((-g.x-x.x)/i,(-g.y-x.y)/o),P=_.angleRadians(),T=b.angleRadians()-P;T%=2*Math.PI,!c&&T>0?T-=2*Math.PI:c&&T<0&&(T+=2*Math.PI);let S=Math.ceil(Math.abs(T)/(2*Math.PI)*s)+1;S<1&&(S=1);for(let e=1;e<=S;e++){let t=P+e/S*T,r=Math.cos(t),s=Math.sin(t),l=new K(n*i*r-a*o*s,a*i*r+n*o*s).plus(v);p.push(l)}}p=this.points.concat(p);let f=new W(p);return f}};const L=function(e,t){this.normal=e,this.w=t};L.fromObject=function(e){let t=new J(e.normal),n=parseFloat(e.w);return new L(t,n)},L.fromVector3Ds=function(e,t,n){let r=t.minus(e).cross(n.minus(e)).unit();return new L(r,r.dot(e))},L.anyPlaneFromVector3Ds=function(e,n,r){let i=n.minus(e),o=r.minus(e);i.length()<t.EPS&&(i=o.randomNonParallelVector()),o.length()<t.EPS&&(o=i.randomNonParallelVector());let s=i.cross(o);return s.length()<t.EPS&&(o=i.randomNonParallelVector(),s=i.cross(o)),s=s.unit(),new L(s,s.dot(e))},L.fromPoints=function(e,t,n){return e=new J(e),t=new J(t),n=new J(n),L.fromVector3Ds(e,t,n)},L.fromNormalAndPoint=function(e,t){e=new J(e),t=new J(t),e=e.unit();let n=t.dot(e);return new L(e,n)},L.prototype={flipped:function(){return new L(this.normal.negated(),-this.w)},getTag:function(){let e=this.tag;return e||(e=window.getTag(),this.tag=e),e},equals:function(e){return this.normal.equals(e.normal)&&this.w===e.w},transform:function(e){let t=e.isMirroring(),n=this.normal.randomNonParallelVector(),r=this.normal.cross(n),i=this.normal.cross(r),o=this.normal.times(this.w),s=o.plus(r),l=o.plus(i);o=o.multiply4x4(e),s=s.multiply4x4(e),l=l.multiply4x4(e);let a=L.fromVector3Ds(o,s,l);return t&&(a=a.flipped()),a},splitLineBetweenPoints:function(e,t){let n=t.minus(e),r=(this.w-this.normal.dot(e))/this.normal.dot(n);return isNaN(r)&&(r=0),r>1&&(r=1),r<0&&(r=0),e.plus(n.times(r))},intersectWithLine:function(e){return e.intersectWithPlane(this)},intersectWithPlane:function(e){return G.fromPlanes(this,e)},signedDistanceToPoint:function(e){return this.normal.dot(e)-this.w},toString:function(){return"[normal: "+this.normal.toString()+", w: "+this.w+"]"},mirrorPoint:function(e){let t=this.signedDistanceToPoint(e);return e.minus(this.normal.times(2*t))}};let U=function(e,n,r){if(this.vertices=e,n||(n=U.defaultShared),this.shared=n,this.plane=arguments.length>=3?r:L.fromVector3Ds(e[0].pos,e[1].pos,e[2].pos),t._CSGDEBUG&&!this.checkIfConvex())throw new Error("Not convex!")};U.prototype={checkIfConvex:function(){return U.verticesConvex(this.vertices,this.plane.normal)},setColor:function(e){let t=U.Shared.fromColor.apply(this,arguments);return this.shared=t,this},getSignedVolume:function(){let e=0;for(let t=0;t<this.vertices.length-2;t++)e+=this.vertices[0].pos.dot(this.vertices[t+1].pos.cross(this.vertices[t+2].pos));return e/=6,e},getArea:function(){let e=0;for(let t=0;t<this.vertices.length-2;t++)e+=this.vertices[t+1].pos.minus(this.vertices[0].pos).cross(this.vertices[t+2].pos.minus(this.vertices[t+1].pos)).length();return e/=2,e},getTetraFeatures:function(e){let t=[];return e.forEach((function(e){"volume"===e?t.push(this.getSignedVolume()):"area"===e&&t.push(this.getArea())}),this),t},extrude:function(e){let t=[],n=this;n.plane.normal.dot(e)>0&&(n=n.flipped()),t.push(n);let r=n.translate(e),i=this.vertices.length;for(let e=0;e<i;e++){let o=[],s=e<i-1?e+1:0;o.push(n.vertices[e].pos),o.push(r.vertices[e].pos),o.push(r.vertices[s].pos),o.push(n.vertices[s].pos);let l=U.createFromPoints(o,this.shared);t.push(l)}return r=r.flipped(),t.push(r),f(t)},translate:function(e){return this.transform(X.translation(e))},boundingSphere:function(){if(!this.cachedBoundingSphere){let e=this.boundingBox(),t=e[0].plus(e[1]).times(.5),n=e[1].minus(t).length();this.cachedBoundingSphere=[t,n]}return this.cachedBoundingSphere},boundingBox:function(){if(!this.cachedBoundingBox){let e,t,n=this.vertices,r=n.length;e=0===r?new J(0,0,0):n[0].pos,t=e;for(let i=1;i<r;i++){let r=n[i].pos;e=e.min(r),t=t.max(r)}this.cachedBoundingBox=[e,t]}return this.cachedBoundingBox},flipped:function(){let e=this.vertices.map((function(e){return e.flipped()}));e.reverse();let t=this.plane.flipped();return new U(e,this.shared,t)},transform:function(e){let t=this.vertices.map((function(t){return t.transform(e)})),n=this.plane.transform(e);return e.isMirroring()&&t.reverse(),new U(t,this.shared,n)},toString:function(){let e="Polygon plane: "+this.plane.toString()+"\n";return this.vertices.map((function(t){e+="  "+t.toString()+"\n"})),e},projectToOrthoNormalBasis:function(e){let n=this.vertices.map((function(t){return e.to2D(t.pos)})),r=x(n),o=r.area();return Math.abs(o)<t.areaEPS?r=new i:o<0&&(r=r.flipped()),r},solidFromSlices:function(e){return fe(this,e)}},U.fromObject=function(e){let t=e.vertices.map((function(e){return Q.fromObject(e)})),n=U.Shared.fromObject(e.shared),r=L.fromObject(e.plane);return new U(t,n,r)},U.createFromPoints=function(e,t,n){let r,i=[];return e.map((function(e){let t=new J(e),n=new Q(t);i.push(n)})),r=arguments.length<3?new U(i,t):new U(i,t,n),r},U.verticesConvex=function(e,t){let n=e.length;if(n>2){let r=e[n-2].pos,i=e[n-1].pos;for(let o=0;o<n;o++){let n=e[o].pos;if(!U.isConvexPoint(r,i,n,t))return!1;r=i,i=n}}return!0},U.isConvexPoint=function(e,t,n,r){return t.minus(e).cross(n.minus(t)).dot(r)>=0},U.isStrictlyConvexPoint=function(e,n,r,i){return n.minus(e).cross(r.minus(n)).dot(i)>=t.EPS},U.Shared=function(e){if(null!=e&&4!==e.length)throw new Error("Expecting 4 element array");this.color=e},U.Shared.fromObject=function(e){return new U.Shared(e.color)},U.Shared.fromColor=function(e){let t;if(1===arguments.length)t=arguments[0].slice();else{t=[];for(let e=0;e<arguments.length;e++)t.push(arguments[e])}if(3===t.length)t.push(1);else if(4!==t.length)throw new Error("setColor expects either an array with 3 or 4 elements, or 3 or 4 parameters.");return new U.Shared(t)},U.Shared.prototype={getTag:function(){let e=this.tag;return e||(e=window.getTag(),this.tag=e),e},getHash:function(){return this.color?this.color.join("/"):"null"}},U.defaultShared=new U.Shared(null);const H=function(e,t){if(!(e instanceof $))throw new Error("Assertion failed");if(!(t instanceof $))throw new Error("Assertion failed");this.vertex0=e,this.vertex1=t};H.fromObject=function(e){var t=$.fromObject(e.vertex0),n=$.fromObject(e.vertex1);return new H(t,n)},H._fromFakePolygon=function(e){if(e.vertices.length<4)return null;var t=[],n=e.vertices.filter((function(e,n){return e.pos.z>0&&(t.push(n),!0)})).map((function(e){return new K(e.pos.x,e.pos.y)}));if(2!==n.length)throw new Error("Assertion failed: _fromFakePolygon: not enough points found");var r=t[1]-t[0];if(1!==r&&3!==r)throw new Error("Assertion failed: _fromFakePolygon: unknown index ordering");return 1===r&&n.reverse(),new H(new $(n[0]),new $(n[1]))},H.prototype={toString:function(){return this.vertex0+" -> "+this.vertex1},toPolygon3D:function(e,t){const n=[new Q(this.vertex0.pos.toVector3D(e)),new Q(this.vertex1.pos.toVector3D(e)),new Q(this.vertex1.pos.toVector3D(t)),new Q(this.vertex0.pos.toVector3D(t))];return new U(n)},transform:function(e){var t=this.vertex0.pos.transform(e),n=this.vertex1.pos.transform(e);return new H(new $(t),new $(n))},flipped:function(){return new H(this.vertex1,this.vertex0)},direction:function(){return this.vertex1.pos.minus(this.vertex0.pos)},getTag:function(){var e=this.tag;return e||(e=window.getTag(),this.tag=e),e},lengthSquared:function(){let e=this.vertex1.pos.x-this.vertex0.pos.x,t=this.vertex1.pos.y-this.vertex0.pos.y;return e*e+t*t},length:function(){return Math.sqrt(this.lengthSquared())}};const J=function(e,t,n){if(3===arguments.length)this._x=parseFloat(e),this._y=parseFloat(t),this._z=parseFloat(n);else if(2===arguments.length)this._x=parseFloat(e),this._y=parseFloat(t),this._z=0;else{var r=!0;if(1===arguments.length)if("object"==typeof e)e instanceof J?(this._x=e._x,this._y=e._y,this._z=e._z):e instanceof K?(this._x=e._x,this._y=e._y,this._z=0):e instanceof Array?e.length<2||e.length>3?r=!1:(this._x=parseFloat(e[0]),this._y=parseFloat(e[1]),3===e.length?this._z=parseFloat(e[2]):this._z=0):"x"in e&&"y"in e?(this._x=parseFloat(e.x),this._y=parseFloat(e.y),this._z="z"in e?parseFloat(e.z):0):"_x"in e&&"_y"in e?(this._x=parseFloat(e._x),this._y=parseFloat(e._y),this._z="_z"in e?parseFloat(e._z):0):r=!1;else{var i=parseFloat(e);this._x=i,this._y=i,this._z=i}else r=!1;if(!r)throw new Error("wrong arguments");D(this._x)&&D(this._y)&&D(this._z)||(r=!1)}};J.Create=function(e,t,n){var r=Object.create(J.prototype);return r._x=e,r._y=t,r._z=n,r},J.prototype={get x(){return this._x},get y(){return this._y},get z(){return this._z},set x(e){throw new Error("Vector is immutable")},set y(e){throw new Error("Vector is immutable")},set z(e){throw new Error("Vector is immutable")},clone:function(){return J.Create(this._x,this._y,this._z)},negated:function(){return J.Create(-this._x,-this._y,-this._z)},abs:function(){return J.Create(Math.abs(this._x),Math.abs(this._y),Math.abs(this._z))},plus:function(e){return J.Create(this._x+e._x,this._y+e._y,this._z+e._z)},minus:function(e){return J.Create(this._x-e._x,this._y-e._y,this._z-e._z)},times:function(e){return J.Create(this._x*e,this._y*e,this._z*e)},dividedBy:function(e){return J.Create(this._x/e,this._y/e,this._z/e)},dot:function(e){return this._x*e._x+this._y*e._y+this._z*e._z},lerp:function(e,t){return this.plus(e.minus(this).times(t))},lengthSquared:function(){return this.dot(this)},length:function(){return Math.sqrt(this.lengthSquared())},unit:function(){return this.dividedBy(this.length())},cross:function(e){return J.Create(this._y*e._z-this._z*e._y,this._z*e._x-this._x*e._z,this._x*e._y-this._y*e._x)},distanceTo:function(e){return this.minus(e).length()},distanceToSquared:function(e){return this.minus(e).lengthSquared()},equals:function(e){return this._x===e._x&&this._y===e._y&&this._z===e._z},multiply4x4:function(e){return e.leftMultiply1x3Vector(this)},transform:function(e){return e.leftMultiply1x3Vector(this)},toString:function(){return"("+this._x.toFixed(5)+", "+this._y.toFixed(5)+", "+this._z.toFixed(5)+")"},randomNonParallelVector:function(){var e=this.abs();return e._x<=e._y&&e._x<=e._z?J.Create(1,0,0):e._y<=e._x&&e._y<=e._z?J.Create(0,1,0):J.Create(0,0,1)},min:function(e){return J.Create(Math.min(this._x,e._x),Math.min(this._y,e._y),Math.min(this._z,e._z))},max:function(e){return J.Create(Math.max(this._x,e._x),Math.max(this._y,e._y),Math.max(this._z,e._z))}};const K=function(e,t){if(2===arguments.length)this._x=parseFloat(e),this._y=parseFloat(t);else{var n=!0;if(1===arguments.length)if("object"==typeof e)e instanceof K?(this._x=e._x,this._y=e._y):e instanceof Array?(this._x=parseFloat(e[0]),this._y=parseFloat(e[1])):"x"in e&&"y"in e?(this._x=parseFloat(e.x),this._y=parseFloat(e.y)):n=!1;else{var r=parseFloat(e);this._x=r,this._y=r}else n=!1;if(n&&(D(this._x)&&D(this._y)||(n=!1)),!n)throw new Error("wrong arguments")}};K.fromAngle=function(e){return K.fromAngleRadians(e)},K.fromAngleDegrees=function(e){var t=Math.PI*e/180;return K.fromAngleRadians(t)},K.fromAngleRadians=function(e){return K.Create(Math.cos(e),Math.sin(e))},K.Create=function(e,t){var n=Object.create(K.prototype);return n._x=e,n._y=t,n},K.prototype={get x(){return this._x},get y(){return this._y},set x(e){throw new Error("Vector2D is immutable")},set y(e){throw new Error("Vector2D is immutable")},toVector3D:function(e){return new J(this._x,this._y,e)},equals:function(e){return this._x===e._x&&this._y===e._y},clone:function(){return K.Create(this._x,this._y)},negated:function(){return K.Create(-this._x,-this._y)},plus:function(e){return K.Create(this._x+e._x,this._y+e._y)},minus:function(e){return K.Create(this._x-e._x,this._y-e._y)},times:function(e){return K.Create(this._x*e,this._y*e)},dividedBy:function(e){return K.Create(this._x/e,this._y/e)},dot:function(e){return this._x*e._x+this._y*e._y},lerp:function(e,t){return this.plus(e.minus(this).times(t))},length:function(){return Math.sqrt(this.dot(this))},distanceTo:function(e){return this.minus(e).length()},distanceToSquared:function(e){return this.minus(e).lengthSquared()},lengthSquared:function(){return this.dot(this)},unit:function(){return this.dividedBy(this.length())},cross:function(e){return this._x*e._y-this._y*e._x},normal:function(){return K.Create(this._y,-this._x)},multiply4x4:function(e){return e.leftMultiply1x2Vector(this)},transform:function(e){return e.leftMultiply1x2Vector(this)},angle:function(){return this.angleRadians()},angleDegrees:function(){return 180*this.angleRadians()/Math.PI},angleRadians:function(){return Math.atan2(this._y,this._x)},min:function(e){return K.Create(Math.min(this._x,e._x),Math.min(this._y,e._y))},max:function(e){return K.Create(Math.max(this._x,e._x),Math.max(this._y,e._y))},toString:function(){return"("+this._x.toFixed(5)+", "+this._y.toFixed(5)+")"},abs:function(){return K.Create(Math.abs(this._x),Math.abs(this._y))}};const Q=function(e){this.pos=e};Q.fromObject=function(e){var t=new J(e.pos);return new Q(t)},Q.prototype={flipped:function(){return this},getTag:function(){var e=this.tag;return e||(e=window.getTag(),this.tag=e),e},interpolate:function(e,t){var n=this.pos.lerp(e.pos,t);return new Q(n)},transform:function(e){var t=this.pos.multiply4x4(e);return new Q(t)},toString:function(){return this.pos.toString()}};const $=function(e){this.pos=e};$.fromObject=function(e){return new $(new K(e.pos._x,e.pos._y))},$.prototype={toString:function(){return"("+this.pos.x.toFixed(5)+","+this.pos.y.toFixed(5)+")"},getTag:function(){var e=this.tag;return e||(e=window.getTag(),this.tag=e),e}};const ee=function(e,n,r,i){if(n.equals(r)||i.equals(e)){if(i.minus(r).unit().plus(n.minus(e).unit()).length()<t.EPS)return!0}else{let t=n.minus(e),o=i.minus(r);if(Math.abs(t.cross(o))<1e-9)return!1;let s=B(-t.x,o.x,-t.y,o.y,e.x-r.x,e.y-r.y);if(s[0]>1e-6&&s[0]<.999999&&s[1]>1e-5&&s[1]<.999999)return!0}return!1},te=function(e,n){let r=e.length;if(r>0){let i=e[0].plane,o=e[0].shared,s=new Y(i),l=[],a=[],u={},h={},c={},p=1/t.EPS*10;for(let t=0;t<r;t++){let n=e[t],r=[],i=n.vertices.length,o=-1;if(i>0){let e,l;for(let a=0;a<i;a++){let i,u=s.to2D(n.vertices[a].pos),f=Math.floor(u.y*p);f in c?i=c[f]:f+1 in c?i=c[f+1]:f-1 in c?i=c[f-1]:(i=u.y,c[f]=u.y),u=K.Create(u.x,i),r.push(u);let m=u.y;(0===a||m<e)&&(e=m,o=a),(0===a||m>l)&&(l=m),m in h||(h[m]={}),h[m][t]=!0}e>=l?(r=[],i=0,o=-1):(e in u||(u[e]=[]),u[e].push(t))}r.reverse(),o=i-o-1,l.push(r),a.push(o)}let f=[];for(let e in h)f.push(e);f.sort(k);let m=[],d=[];for(let e=0;e<f.length;e++){let r,c=[],p=f[e],g=Number(p),w=h[p];for(let e=0;e<m.length;++e){let t=m[e],n=t.polygonindex;if(w[n]){let r=l[n],i=r.length,o=t.leftvertexindex,s=t.rightvertexindex;for(;;){let e=o+1;if(e>=i&&(e=0),r[e].y!==g)break;o=e}let a=s-1;if(a<0&&(a=i-1),r[a].y===g&&(s=a),o!==t.leftvertexindex&&o===s)m.splice(e,1),--e;else{t.leftvertexindex=o,t.rightvertexindex=s,t.topleft=r[o],t.topright=r[s];let e=o+1;e>=i&&(e=0),t.bottomleft=r[e];let n=s-1;n<0&&(n=i-1),t.bottomright=r[n]}}}if(e>=f.length-1)m=[],r=null;else{r=Number(f[e+1]);let t=.5*(g+r),n=u[p];for(let e in n){let r=n[e],i=l[r],o=i.length,s=a[r],u=s;for(;;){let e=u+1;if(e>=o&&(e=0),i[e].y!==g)break;if(e===s)break;u=e}let h=s;for(;;){let e=h-1;if(e<0&&(e=o-1),i[e].y!==g)break;if(e===u)break;h=e}let c=u+1;c>=o&&(c=0);let p=h-1;p<0&&(p=o-1),F(m,{polygonindex:r,leftvertexindex:u,rightvertexindex:h,topleft:i[u],topright:i[h],bottomleft:i[c],bottomright:i[p]},(function(e,n){let r=I(e.topleft,e.bottomleft,t),i=I(n.topleft,n.bottomleft,t);return r>i?1:r<i?-1:0}))}}for(let e in m){let n=m[e],i=(l[n.polygonindex].length,I(n.topleft,n.bottomleft,g)),o=K.Create(i,g);i=I(n.topright,n.bottomright,g);let s=K.Create(i,g);i=I(n.topleft,n.bottomleft,r);let a=K.Create(i,r);i=I(n.topright,n.bottomright,r);let u=K.Create(i,r),h={topleft:o,topright:s,bottomleft:a,bottomright:u,leftline:Z.fromPoints(o,a),rightline:Z.fromPoints(u,s)};if(c.length>0){let e=c[c.length-1],n=h.topleft.distanceTo(e.topright),r=h.bottomleft.distanceTo(e.bottomright);n<t.EPS&&r<t.EPS&&(h.topleft=e.topleft,h.leftline=e.leftline,h.bottomleft=e.bottomleft,c.splice(c.length-1,1))}c.push(h)}if(e>0){let e={},r={};for(let n=0;n<c.length;n++){let i=c[n];for(let n=0;n<d.length;n++)if(!r[n]){let o=d[n];if(o.bottomleft.distanceTo(i.topleft)<t.EPS&&o.bottomright.distanceTo(i.topright)<t.EPS){r[n]=!0;let s=i.leftline.direction().x-o.leftline.direction().x,l=i.rightline.direction().x-o.rightline.direction().x,a=Math.abs(s)<t.EPS,u=Math.abs(l)<t.EPS,h=u||l>=0;(a||s>=0)&&h&&(i.outpolygon=o.outpolygon,i.leftlinecontinues=a,i.rightlinecontinues=u,e[n]=!0);break}}}for(let r=0;r<d.length;r++)if(!e[r]){let e=d[r];e.outpolygon.rightpoints.push(e.bottomright),e.bottomright.distanceTo(e.bottomleft)>t.EPS&&e.outpolygon.leftpoints.push(e.bottomleft),e.outpolygon.leftpoints.reverse();let l=e.outpolygon.rightpoints.concat(e.outpolygon.leftpoints),a=[];l.map((function(e){let t=s.to3D(e),n=new Q(t);a.push(n)}));let u=new U(a,o,i);n.push(u)}}for(let e=0;e<c.length;e++){let n=c[e];n.outpolygon?(n.leftlinecontinues||n.outpolygon.leftpoints.push(n.topleft),n.rightlinecontinues||n.outpolygon.rightpoints.push(n.topright)):(n.outpolygon={leftpoints:[],rightpoints:[]},n.outpolygon.leftpoints.push(n.topleft),n.topleft.distanceTo(n.topright)>t.EPS&&n.outpolygon.rightpoints.push(n.topright))}d=c}}},ne={black:[0,0,0],silver:[192/255,192/255,192/255],gray:[128/255,128/255,128/255],white:[1,1,1],maroon:[128/255,0,0],red:[1,0,0],purple:[128/255,0,128/255],fuchsia:[1,0,1],green:[0,128/255,0],lime:[0,1,0],olive:[128/255,128/255,0],yellow:[1,1,0],navy:[0,0,128/255],blue:[0,0,1],teal:[0,128/255,128/255],aqua:[0,1,1],aliceblue:[240/255,248/255,1],antiquewhite:[250/255,235/255,215/255],aquamarine:[127/255,1,212/255],azure:[240/255,1,1],beige:[245/255,245/255,220/255],bisque:[1,228/255,196/255],blanchedalmond:[1,235/255,205/255],blueviolet:[138/255,43/255,226/255],brown:[165/255,42/255,42/255],burlywood:[222/255,184/255,135/255],cadetblue:[95/255,158/255,160/255],chartreuse:[127/255,1,0],chocolate:[210/255,105/255,30/255],coral:[1,127/255,80/255],cornflowerblue:[100/255,149/255,237/255],cornsilk:[1,248/255,220/255],crimson:[220/255,20/255,60/255],cyan:[0,1,1],darkblue:[0,0,139/255],darkcyan:[0,139/255,139/255],darkgoldenrod:[184/255,134/255,11/255],darkgray:[169/255,169/255,169/255],darkgreen:[0,100/255,0],darkgrey:[169/255,169/255,169/255],darkkhaki:[189/255,183/255,107/255],darkmagenta:[139/255,0,139/255],darkolivegreen:[85/255,107/255,47/255],darkorange:[1,140/255,0],darkorchid:[.6,50/255,.8],darkred:[139/255,0,0],darksalmon:[233/255,150/255,122/255],darkseagreen:[143/255,188/255,143/255],darkslateblue:[72/255,61/255,139/255],darkslategray:[47/255,79/255,79/255],darkslategrey:[47/255,79/255,79/255],darkturquoise:[0,206/255,209/255],darkviolet:[148/255,0,211/255],deeppink:[1,20/255,147/255],deepskyblue:[0,191/255,1],dimgray:[105/255,105/255,105/255],dimgrey:[105/255,105/255,105/255],dodgerblue:[30/255,144/255,1],firebrick:[178/255,34/255,34/255],floralwhite:[1,250/255,240/255],forestgreen:[34/255,139/255,34/255],gainsboro:[220/255,220/255,220/255],ghostwhite:[248/255,248/255,1],gold:[1,215/255,0],goldenrod:[218/255,165/255,32/255],greenyellow:[173/255,1,47/255],grey:[128/255,128/255,128/255],honeydew:[240/255,1,240/255],hotpink:[1,105/255,180/255],indianred:[205/255,92/255,92/255],indigo:[75/255,0,130/255],ivory:[1,1,240/255],khaki:[240/255,230/255,140/255],lavender:[230/255,230/255,250/255],lavenderblush:[1,240/255,245/255],lawngreen:[124/255,252/255,0],lemonchiffon:[1,250/255,205/255],lightblue:[173/255,216/255,230/255],lightcoral:[240/255,128/255,128/255],lightcyan:[224/255,1,1],lightgoldenrodyellow:[250/255,250/255,210/255],lightgray:[211/255,211/255,211/255],lightgreen:[144/255,238/255,144/255],lightgrey:[211/255,211/255,211/255],lightpink:[1,182/255,193/255],lightsalmon:[1,160/255,122/255],lightseagreen:[32/255,178/255,170/255],lightskyblue:[135/255,206/255,250/255],lightslategray:[119/255,136/255,.6],lightslategrey:[119/255,136/255,.6],lightsteelblue:[176/255,196/255,222/255],lightyellow:[1,1,224/255],limegreen:[50/255,205/255,50/255],linen:[250/255,240/255,230/255],magenta:[1,0,1],mediumaquamarine:[.4,205/255,170/255],mediumblue:[0,0,205/255],mediumorchid:[186/255,85/255,211/255],mediumpurple:[147/255,112/255,219/255],mediumseagreen:[60/255,179/255,113/255],mediumslateblue:[123/255,104/255,238/255],mediumspringgreen:[0,250/255,154/255],mediumturquoise:[72/255,209/255,.8],mediumvioletred:[199/255,21/255,133/255],midnightblue:[25/255,25/255,112/255],mintcream:[245/255,1,250/255],mistyrose:[1,228/255,225/255],moccasin:[1,228/255,181/255],navajowhite:[1,222/255,173/255],oldlace:[253/255,245/255,230/255],olivedrab:[107/255,142/255,35/255],orange:[1,165/255,0],orangered:[1,69/255,0],orchid:[218/255,112/255,214/255],palegoldenrod:[238/255,232/255,170/255],palegreen:[152/255,251/255,152/255],paleturquoise:[175/255,238/255,238/255],palevioletred:[219/255,112/255,147/255],papayawhip:[1,239/255,213/255],peachpuff:[1,218/255,185/255],peru:[205/255,133/255,63/255],pink:[1,192/255,203/255],plum:[221/255,160/255,221/255],powderblue:[176/255,224/255,230/255],rosybrown:[188/255,143/255,143/255],royalblue:[65/255,105/255,225/255],saddlebrown:[139/255,69/255,19/255],salmon:[250/255,128/255,114/255],sandybrown:[244/255,164/255,96/255],seagreen:[46/255,139/255,87/255],seashell:[1,245/255,238/255],sienna:[160/255,82/255,45/255],skyblue:[135/255,206/255,235/255],slateblue:[106/255,90/255,205/255],slategray:[112/255,128/255,144/255],slategrey:[112/255,128/255,144/255],snow:[1,250/255,250/255],springgreen:[0,1,127/255],steelblue:[70/255,130/255,180/255],tan:[210/255,180/255,140/255],thistle:[216/255,191/255,216/255],tomato:[1,99/255,71/255],turquoise:[64/255,224/255,208/255],violet:[238/255,130/255,238/255],wheat:[245/255,222/255,179/255],whitesmoke:[245/255,245/255,245/255],yellowgreen:[154/255,205/255,50/255]};function re(e){return ne[e.toLowerCase()]}function ie(e){let t,n=1,r=arguments;for("string"==typeof e&&(e=re(e)),Number.isFinite(r[n])&&(e=e.concat(r[n]),n++),Array.isArray(r[n])&&(r=r[n],n=0),t=r[n++];n<r.length;n++)t=t.union(r[n]);return t.setColor(e)}const oe=function(e){let t,n,i,o;if("corner1"in(e=e||{})||"corner2"in e){if("center"in e||"radius"in e)throw new Error("cube: should either give a radius and center parameter, or a corner1 and corner2 parameter");i=Ee(e,"corner1",[0,0,0]),o=Ee(e,"corner2",[1,1,1]),t=i.plus(o).times(.5),n=o.minus(i).times(.5)}else t=Ee(e,"center",[0,0,0]),n=Ee(e,"radius",[1,1,1]);n=n.abs();let s=f([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map((function(e){let r=e[0].map((function(e){let r=new J(t.x+n.x*(2*!!(1&e)-1),t.y+n.y*(2*!!(2&e)-1),t.z+n.z*(2*!!(4&e)-1));return new Q(r)}));return new U(r,null)})));return s.properties.cube=new u,s.properties.cube.center=new J(t),s.properties.cube.facecenters=[new r(new J([n.x,0,0]).plus(t),[1,0,0],[0,0,1]),new r(new J([-n.x,0,0]).plus(t),[-1,0,0],[0,0,1]),new r(new J([0,n.y,0]).plus(t),[0,1,0],[0,0,1]),new r(new J([0,-n.y,0]).plus(t),[0,-1,0],[0,0,1]),new r(new J([0,0,n.z]).plus(t),[0,0,1],[1,0,0]),new r(new J([0,0,-n.z]).plus(t),[0,0,-1],[1,0,0])],s},se=function(e){let n,r,i,o=Ee(e=e||{},"center",[0,0,0]),s=Ae(e,"radius",1),l=De(e,"resolution",t.defaultResolution3D);"axes"in e?(n=e.axes[0].unit().times(s),r=e.axes[1].unit().times(s),i=e.axes[2].unit().times(s)):(n=new J([1,0,0]).times(s),r=new J([0,-1,0]).times(s),i=new J([0,0,1]).times(s)),l<4&&(l=4);let a,h=Math.round(l/4),c=[];for(let e=0;e<=l;e++){let t=2*Math.PI*e/l,s=n.times(Math.cos(t)).plus(r.times(Math.sin(t)));if(e>0){let e,t,n=[];for(let r=0;r<=h;r++){let l=.5*Math.PI*r/h,u=Math.cos(l),p=Math.sin(l);r>0&&(n=[],n.push(new Q(o.plus(a.times(e).minus(i.times(t))))),n.push(new Q(o.plus(s.times(e).minus(i.times(t))))),r<h&&n.push(new Q(o.plus(s.times(u).minus(i.times(p))))),n.push(new Q(o.plus(a.times(u).minus(i.times(p))))),c.push(new U(n)),n=[],n.push(new Q(o.plus(a.times(e).plus(i.times(t))))),n.push(new Q(o.plus(s.times(e).plus(i.times(t))))),r<h&&n.push(new Q(o.plus(s.times(u).plus(i.times(p))))),n.push(new Q(o.plus(a.times(u).plus(i.times(p))))),n.reverse(),c.push(new U(n))),e=u,t=p}}a=s}let p=f(c);return p.properties.sphere=new u,p.properties.sphere.center=new J(o),p.properties.sphere.facepoint=o.plus(n),p},le=function(e){let n=Ee(e,"start",[0,-1,0]),i=Ee(e,"end",[0,1,0]),o=Ae(e,"radius",1),s=Ae(e,"radiusEnd",o),l=Ae(e,"radiusStart",o),a=Ae(e,"sectorAngle",360);if(a=a>360?a%360:a,s<0||l<0)throw new Error("Radius should be non-negative");if(0===s&&0===l)throw new Error("Either radiusStart or radiusEnd should be positive");let h=De(e,"resolution",t.defaultResolution2D),c=i.minus(n),p=c.unit(),m=p.randomNonParallelVector().unit(),d=m.cross(p).unit(),g=new Q(n),w=new Q(i),y=[];function x(e,t,r){let i=t*Math.PI*a/180,o=m.times(Math.cos(i)).plus(d.times(Math.sin(i))),s=n.plus(c.times(e)).plus(o.times(r));return new Q(s)}if(a>0){for(let e=0;e<h;e++){let t=e/h,n=(e+1)/h;s===l?(y.push(new U([g,x(0,t,s),x(0,n,s)])),y.push(new U([x(0,n,s),x(0,t,s),x(1,t,s),x(1,n,s)])),y.push(new U([w,x(1,n,s),x(1,t,s)]))):(l>0&&(y.push(new U([g,x(0,t,l),x(0,n,l)])),y.push(new U([x(0,t,l),x(1,t,s),x(0,n,l)]))),s>0&&(y.push(new U([w,x(1,n,s),x(1,t,s)])),y.push(new U([x(1,t,s),x(1,n,s),x(0,n,l)]))))}a<360&&(y.push(new U([g,w,x(0,0,l)])),y.push(new U([x(0,0,l),w,x(1,0,s)])),y.push(new U([g,x(0,1,l),w])),y.push(new U([x(0,1,l),x(1,1,s),w])))}let v=f(y);v.properties.cylinder=new u,v.properties.cylinder.start=new r(n,p.negated(),m),v.properties.cylinder.end=new r(i,p,m);let _=n.plus(c.times(.5)),b=m.rotate(n,p,-a/2).times((l+s)/2),P=b.cross(p);return v.properties.cylinder.facepointH=new r(_.plus(b),b,p),v.properties.cylinder.facepointH90=new r(_.plus(P),P,p),v},ae=function(e){let n,i=Ee(e,"start",[0,-1,0]),o=Ee(e,"end",[0,1,0]),s=Ae(e,"radius",1),l=o.minus(i);n=Math.abs(l.x)>Math.abs(l.y)?new J(0,1,0):new J(1,0,0);let a=Ee(e,"normal",n),h=De(e,"resolution",t.defaultResolution3D);h<4&&(h=4);let c=[],p=Math.floor(.25*h);if(l.length()<t.EPS)return se({center:i,radius:s,resolution:h});let m,d=l.unit().times(s),g=d.cross(a).unit().times(s),w=g.cross(d).unit().times(s);for(let e=0;e<=h;e++){let t=2*Math.PI*e/h,n=g.times(Math.cos(t)).plus(w.times(Math.sin(t)));if(e>0){let e,t,r=[];r.push(new Q(i.plus(n))),r.push(new Q(i.plus(m))),r.push(new Q(o.plus(m))),r.push(new Q(o.plus(n))),c.push(new U(r));for(let s=0;s<=p;s++){let l=.5*Math.PI*s/p,a=Math.cos(l),u=Math.sin(l);s>0&&(r=[],r.push(new Q(i.plus(m.times(e).minus(d.times(t))))),r.push(new Q(i.plus(n.times(e).minus(d.times(t))))),s<p&&r.push(new Q(i.plus(n.times(a).minus(d.times(u))))),r.push(new Q(i.plus(m.times(a).minus(d.times(u))))),c.push(new U(r)),r=[],r.push(new Q(o.plus(m.times(e).plus(d.times(t))))),r.push(new Q(o.plus(n.times(e).plus(d.times(t))))),s<p&&r.push(new Q(o.plus(n.times(a).plus(d.times(u))))),r.push(new Q(o.plus(m.times(a).plus(d.times(u))))),r.reverse(),c.push(new U(r))),e=a,t=u}}m=n}let y=f(c),x=d.unit(),v=g.unit();return y.properties.roundedCylinder=new u,y.properties.roundedCylinder.start=new r(i,x.negated(),v),y.properties.roundedCylinder.end=new r(o,x,v),y.properties.roundedCylinder.facepoint=i.plus(g),y},ue=function(e){let n=Ee(e,"start",[0,-1,0]),i=Ee(e,"end",[0,1,0]),o=ke(e,"radius",[1,1]),s=ke(e,"radiusEnd",o),l=ke(e,"radiusStart",o);if(s._x<0||l._x<0||s._y<0||l._y<0)throw new Error("Radius should be non-negative");if(!(0!==s._x&&0!==s._y||0!==l._x&&0!==l._y))throw new Error("Either radiusStart or radiusEnd should be positive");let a=De(e,"resolution",t.defaultResolution2D),h=i.minus(n),c=h.unit(),p=c.randomNonParallelVector().unit(),m=p.cross(c).unit(),d=new Q(n),g=new Q(i),w=[];function y(e,t,r){let i=t*Math.PI*2,o=p.times(r._x*Math.cos(i)).plus(m.times(r._y*Math.sin(i))),s=n.plus(h.times(e)).plus(o);return new Q(s)}for(let e=0;e<a;e++){let t=e/a,n=(e+1)/a;s._x===l._x&&s._y===l._y?(w.push(new U([d,y(0,t,s),y(0,n,s)])),w.push(new U([y(0,n,s),y(0,t,s),y(1,t,s),y(1,n,s)])),w.push(new U([g,y(1,n,s),y(1,t,s)]))):(l._x>0&&(w.push(new U([d,y(0,t,l),y(0,n,l)])),w.push(new U([y(0,t,l),y(1,t,s),y(0,n,l)]))),s._x>0&&(w.push(new U([g,y(1,n,s),y(1,t,s)])),w.push(new U([y(1,t,s),y(1,n,s),y(0,n,l)]))))}let x=f(w);return x.properties.cylinder=new u,x.properties.cylinder.start=new r(n,c.negated(),p),x.properties.cylinder.end=new r(i,c,p),x.properties.cylinder.facepoint=n.plus(p.times(l)),x},he=function(e){let n,i,o,s;if("corner1"in(e=e||{})||"corner2"in e){if("center"in e||"radius"in e)throw new Error("roundedCube: should either give a radius and center parameter, or a corner1 and corner2 parameter");o=Ee(e,"corner1",[0,0,0]),s=Ee(e,"corner2",[1,1,1]),n=o.plus(s).times(.5),i=s.minus(o).times(.5)}else n=Ee(e,"center",[0,0,0]),i=Ee(e,"radius",[1,1,1]);i=i.abs();let l=De(e,"resolution",t.defaultResolution3D);l<4&&(l=4),l%2==1&&l<8&&(l=8);let a=Ee(e,"roundradius",[.2,.2,.2]);a=J.Create(Math.max(a.x,.01),Math.max(a.y,.01),Math.max(a.z,.01));let h=i.minus(a);if(h.x<0||h.y<0||h.z<0)throw new Error("roundradius <= radius!");let c=se({radius:1,resolution:l});return c=c.scale(a),h.x>t.EPS&&(c=c.stretchAtPlane([1,0,0],[0,0,0],2*h.x)),h.y>t.EPS&&(c=c.stretchAtPlane([0,1,0],[0,0,0],2*h.y)),h.z>t.EPS&&(c=c.stretchAtPlane([0,0,1],[0,0,0],2*h.z)),c=c.translate([-h.x+n.x,-h.y+n.y,-h.z+n.z]),c=c.reTesselated(),c.properties.roundedCube=new u,c.properties.roundedCube.center=new Q(n),c.properties.roundedCube.facecenters=[new r(new J([i.x,0,0]).plus(n),[1,0,0],[0,0,1]),new r(new J([-i.x,0,0]).plus(n),[-1,0,0],[0,0,1]),new r(new J([0,i.y,0]).plus(n),[0,1,0],[0,0,1]),new r(new J([0,-i.y,0]).plus(n),[0,-1,0],[0,0,1]),new r(new J([0,0,i.z]).plus(n),[0,0,1],[1,0,0]),new r(new J([0,0,-i.z]).plus(n),[0,0,-1],[1,0,0])],c},ce=function(e){if("points"in(e=e||{})!="faces"in e)throw new Error("polyhedron needs 'points' and 'faces' arrays");let t=Ce(e,"points",[[1,1,0],[1,-1,0],[-1,-1,0],[-1,1,0],[0,0,1]]).map((function(e){return new Q(e)})),n=ze(e,"faces",[[0,1,4],[1,2,4],[2,3,4],[3,0,4],[1,0,3],[2,1,3]]);n.forEach((function(e){e.reverse()}));let r=n.map((function(e){return new U(e.map((function(e){return t[e]})))}));return f(r).reTesselated()},pe=function(e){let t=e.canonicalized(),n={},r={};t.sides.map((function(e){let t=e.getTag();n[t]=e;let i=e.vertex0.getTag();i in r||(r[i]=[]),r[i].push(t)}));let i=[];for(;;){let e=null;for(let t in r){let n=r[t];e=n[0],n.splice(0,1),0===n.length&&delete r[t];break}if(null===e)break;let t=[],o=n[e],s=o.vertex0.getTag();for(;;){t.push(o.vertex0.pos);let e=o.vertex1.getTag();if(e===s)break;if(!(e in r))throw new Error("Area is not closed!");let i=r[e],l=-1;if(1===i.length)l=0;else{let e=null,t=o.direction().angleDegrees();for(let r=0;r<i.length;r++){let o=i[r],s=n[o].direction().angleDegrees()-t;s<-180&&(s+=360),s>=180&&(s-=360),(l<0||s>e)&&(l=r,e=s)}}let a=i[l];i.splice(l,1),0===i.length&&delete r[e],o=n[a]}t.length>0&&t.push(t.shift());let l=new W(t,!0);i.push(l)}return i},fe=function(e,t){let n,r=[],i=null,o=null,s=null,l=null,a=2,u=!1,h=null;if(t&&(u=Boolean(t.loop),t.numslices&&(a=t.numslices),t.callback&&(n=t.callback)),!n){let e=U.createFromPoints([[0,0,0],[1,0,0],[1,1,0],[0,1,0]]);n=function(t,n){return 0===t||1===t?e.translate([0,0,t]):null}}for(let t=0,l=a-1;t<=l;t++)if(i=n.call(e,t/l,t),i){if(!(i instanceof U))throw new Error("Polygon.solidFromSlices callback error: Polygon expected");i.checkIfConvex(),o?(null===h&&(h=o.plane.signedDistanceToPoint(i.vertices[0].pos)<0),me(r,o,i,h)):s=i,o=i}if(l=i,u){s.vertices.length===l.vertices.length&&s.vertices.every((function(e,t){return e.pos.equals(l.vertices[t].pos)}))||me(r,l,s,h)}else r.unshift(h?s:s.flipped()),r.push(h?l.flipped():l);return f(r)},me=function(e,t,n,r){let i=t.vertices.slice(0),o=n.vertices.slice(0),s=n.shared||null;i[0].pos.equals(i[i.length-1].pos)||i.push(i[0]),o[0].pos.equals(o[o.length-1].pos)||o.push(o[0]),r&&(i=i.reverse(),o=o.reverse());let l,a=o.length-1,u=i.length-1,h=a-u,c=h>0,p=h<0,f=[];for(let e=Math.abs(h);e>0;e--)f.push({len:1/0,index:-1});if(p)for(let e=0;e<u;e++){l=i[e].pos.distanceToSquared(i[e+1].pos);for(let e=f.length-1;e>=0;e--)if(f[e].len>l){f[e].len=l,f.index=e;break}}else if(c)for(let e=0;e<a;e++){l=o[e].pos.distanceToSquared(o[e+1].pos);for(let e=f.length-1;e>=0;e--)if(f[e].len>l){f[e].len=l,f.index=e;break}}f.sort(A);let m,d,g,w=function(e,t,n,r){return new U([e,t,n],r)},y=i[0],x=o[0];for(let t=0,n=0,r=a+u;t+n<r;){if(f.length){if(c&&n===f[0].index){m=o[++n],e.push(w(m,x,y,s)),x=m,f.shift();continue}if(p&&t===f[0].index){m=i[++t],e.push(w(x,y,m,s)),y=m,f.shift();continue}}d=t<u?x.pos.distanceToSquared(i[t+1].pos):1/0,g=n<a?y.pos.distanceToSquared(o[n+1].pos):1/0,d<=g?(m=i[++t],e.push(w(x,y,m,s)),y=m):n<a&&(m=o[++n],e.push(w(m,x,y,s)),x=m)}return e},de=function(e,t,n){let r;return q(e)?(r=e.union(ye(e,t,n)),r=r.reTesselated(),r.properties=e.properties):r=e.union(we(e,t,n)),r},ge=function(e,t,n){let r;return q(e)?(r=e.subtract(ye(e,t,n)),r=r.reTesselated(),r.properties=e.properties):r=e.subtract(we(e,t,n)),r},we=function(e,n,r){(r=r||8)<4&&(r=4);let o=[],s={};e.canonicalized().sides.map((function(e){let r=e.vertex1.pos.minus(e.vertex0.pos),i=r.length();if(i>t.EPS){r=r.times(1/i);let t=r.normal().times(n),l=[e.vertex1.pos.plus(t),e.vertex1.pos.minus(t),e.vertex0.pos.minus(t),e.vertex0.pos.plus(t)],a=g(l);o.push(a);for(let t=0;t<2;t++){let n=0===t?e.vertex0.pos:e.vertex1.pos,r=0===t?e.vertex1.pos:e.vertex0.pos,i=n.x+" "+n.y;i in s||(s[i]=[]),s[i].push({p1:n,p2:r})}}}));for(let e in s){let i,l,a=s[e],u=a[0].p1;if(2===a.length){let e=a[0].p2,t=a[1].p2;if(i=e.minus(u).angleDegrees(),l=t.minus(u).angleDegrees(),l<i&&(l+=360),l>=i+360&&(l-=360),l<i+180){let e=l;l=i+360,i=e}i+=90,l-=90}else i=0,l=360;let h=l>i+359.999;if(h&&(i=0,l=360),l>i+t.angleEPS){let e=[];h||e.push(u);let t=Math.round(r*(l-i)/360);t<1&&(t=1);for(let r=0;r<=t;r++){let o=i+r/t*(l-i);r===t&&(o=l);let s=u.plus(K.fromAngleDegrees(o).times(n));(!h||r>0)&&e.push(s)}let s=x(e);o.push(s)}}let l=new i;return l=l.union(o),l},ye=function(e,n,r,i){let s,l=e.reTesselated();s=i?l:new o,l.polygons.map((function(e){let t=e.plane.normal.unit().times(2*n),r=e.translate(t.times(-.5)).extrude(t);s=s.unionSub(r,!1,!1)}));let a={};l.polygons.map((function(e){let t=e.vertices.length,n=e.vertices[t-1],r=n.getTag();for(let i=0;i<t;i++){let t,o,s=e.vertices[i],l=s.getTag();t=l<r?l+"-"+r:r+"-"+l,t in a?o=a[t]:(o={v1:n,v2:s,planenormals:[]},a[t]=o),o.planenormals.push(e.plane.normal),r=l,n=s}}));for(let e in a){let i=a[e],o=i.v1.pos,l=i.v2.pos,u=l.minus(o).unit(),h=i.planenormals[0].unit(),c=h.cross(u),p=[];for(let e=0;e<r;e++)p.push(e*Math.PI*2/r);for(let e=0,t=i.planenormals.length;e<t;e++){let t=i.planenormals[e],n=c.dot(t),r=h.dot(t),o=Math.atan2(n,r);o<0&&(o+=2*Math.PI),p.push(o),o=Math.atan2(-n,-r),o<0&&(o+=2*Math.PI),p.push(o)}p=p.sort(k);let m,d,g=p.length,w=[],y=[],x=[];for(let e=-1;e<g;e++){let r=p[e<0?e+g:e],i=Math.sin(r),s=Math.cos(r),a=h.times(s*n).plus(c.times(i*n)),u=o.plus(a),f=l.plus(a),v=!1;if(e>=0&&u.distanceTo(m)<t.EPS&&(v=!0),!v){if(e>=0){w.push(new Q(u)),y.push(new Q(f));let e=[new Q(d),new Q(f),new Q(u),new Q(m)],t=new U(e);x.push(t)}m=u,d=f}}y.reverse(),x.push(new U(w)),x.push(new U(y));let v=f(x);s=s.unionSub(v,!1,!1)}let u={};l.polygons.map((function(e){e.vertices.map((function(t){let n,r=t.getTag();r in u?n=u[r]:(n={pos:t.pos,normals:[]},u[r]=n),n.normals.push(e.plane.normal)}))}));for(let e in u){let t=u[e],i=t.normals[0].unit(),l=null,a=0;for(let e=1;e<t.normals.length;e++){let n=t.normals[e].unit(),r=i.cross(n).length();r>.05&&r>a&&(a=r,l=n)}l||(l=i.randomNonParallelVector());let h=i.cross(l).unit(),c=h.cross(i),p=o.sphere({center:t.pos,radius:n,resolution:r,axes:[i,h,c]});s=s.unionSub(p,!1,!1)}return s},xe=function(e,t,n,r){if(!(t instanceof Y))throw new Error("extrudeInPlane: the first parameter should be a OrthoNormalBasis");let i=e.extrude({offset:[0,0,n]});Be(r,"symmetrical",!1)&&(i=i.translate([0,0,-n/2]));let o=t.getInverseProjectionMatrix();return i=i.transform(o),i},ve=function(e,t,n,r,i){return xe(e,Y.GetCartesian(t,n),r,i)},_e=function(e,n){if(0===e.sides.length)return new o;let i=Ee(n,"offset",[0,0,1]),s=Ae(n,"twistangle",0),l=De(n,"twiststeps",t.defaultResolution3D);if(0===i.z)throw new Error("offset cannot be orthogonal to Z axis");(0===s||l<1)&&(l=1);let a=J.Create(0,1,0),u=[];u=u.concat(e._toPlanePolygons({translation:[0,0,0],normalVector:a,flipped:!(i.z<0)})),u=u.concat(e._toPlanePolygons({translation:i,normalVector:a.rotateZ(s),flipped:i.z<0}));for(let t=0;t<l;t++){let n=new r(i.times(t/l),[0,0,i.z],a.rotateZ(t*s/l)),o=new r(i.times((t+1)/l),[0,0,i.z],a.rotateZ((t+1)*s/l));u=u.concat(e._toWallPolygons({toConnector1:n,toConnector2:o}))}return f(u)},be=function(e,n){let i=Ae(n,"angle",360),o=De(n,"resolution",t.defaultResolution3D);i=i>360?i%360:i;let s=[0,0,0],l=J.Create(0,1,0),a=[0,0,1],u=[],h=new r(s,l,a);if(i>0&&i<360){let t=new r(s,l.rotateZ(-i),a);u=u.concat(e._toPlanePolygons({toConnector:h,flipped:!0})),u=u.concat(e._toPlanePolygons({toConnector:t}))}let c,p=h,m=i/o;for(let n=m;n<=i+t.EPS;n+=m)c=new r(s,l.rotateZ(-n),a),u=u.concat(e._toWallPolygons({toConnector1:p,toConnector2:c})),p=c;return f(u).reTesselated()},Pe=function(e){if(0===e.polygons.length){let e=new X;return[e,e]}{let t=e.canonicalized(),n={};t.polygons.map((function(e){n[e.plane.getTag()]=e.plane}));let i,o,s=new J(1,0,0),l=new J(0,1,0),a=new J(0,0,1),u=new r([0,0,0],[0,0,-1],s),h=new r([0,0,0],[0,0,-1],l),c=!0,p=0,f=0;for(let e in n){let m,d,g=n[e],w=g.normal.times(g.w);if(g.normal.cross(s).length()>g.normal.cross(l).length()){let e=new r(w,g.normal,s);m=e.getTransformationTo(u,!1,0),d=u.getTransformationTo(e,!1,0)}else{let e=new r(w,g.normal,l);m=e.getTransformationTo(h,!1,0),d=h.getTransformationTo(e,!1,0)}let y=t.transform(m),x=-g.normal.dot(a),v=y.getBounds(),_=v[1].z-v[0].z,b=c;if(b||(_<p||_===p&&x>f)&&(b=!0),b){let e=new J([-.5*(v[1].x+v[0].x),-.5*(v[1].y+v[0].y),-v[0].z]);m=m.multiply(X.translation(e)),d=X.translation(e.negated()).multiply(d),p=_,f=x,i=m,o=d}c=!1}return[i,o]}},Te=function(e){return e.getTransformationAndInverseTransformationToFlatLying()[0]},Se=function(e){let t=e.getTransformationToFlatLying();return e.transform(t)},Me=function(e,t){let n=e.canonicalized(),r={};n.sides.map((function(e){e.vertex0.getTag()in r||(r[e.vertex0.getTag()]={pos:e.vertex0.pos,from:[],to:[]}),r[e.vertex0.getTag()].to.push(e.vertex1.pos),e.vertex1.getTag()in r||(r[e.vertex1.getTag()]={pos:e.vertex1.pos,from:[],to:[]}),r[e.vertex1.getTag()].from.push(e.vertex0.pos)}));let i=[];for(let e in r){let n=r[e];if(1===n.from.length&&1===n.to.length){let e=n.from[0],r=n.pos,o=n.to[0],s=r.minus(e).unit(),l=o.minus(r).unit();if(s.cross(l)<.001){let e=l.angleRadians()-s.angleRadians()+Math.PI;e<0?e+=2*Math.PI:e>=2*Math.PI&&(e-=2*Math.PI);let n=l.minus(s).unit(),o=30/180*Math.PI,a=t/Math.cos(o/2),u=r.plus(n.times(a)),h=e+n.angleRadians(),c=2*(Math.PI-e),p=2*Math.ceil(c/o/2),f=[u];for(let e=0;e<=p;e++){let t=h+e/p*c,n=K.fromAngleRadians(t).times(a).plus(u);f.push(n)}i.push(g(f))}}}return n.subtract(i)},ze=function(e,t,n){var r=n;return e&&t in e&&(r=e[t]),r},Ee=function(e,t,n){var r=ze(e,t,n);return r=new J(r)},Ce=function(e,t,n){return ze(e,t,n).map((function(e){return new J(e)}))},ke=function(e,t,n){var r=ze(e,t,n);return r=new K(r)},Ae=function(e,t,n){var r=ze(e,t,n);if("string"==typeof r&&(r=Number(r)),isNaN(r)||"number"!=typeof r)throw new Error("Parameter "+t+" should be a number");return r},De=function(e,t,n){var r=ze(e,t,n);if(r=Number(Math.floor(r)),isNaN(r))throw new Error("Parameter "+t+" should be a number");return r},Be=function(e,t,n){var r=ze(e,t,n);return"string"==typeof r&&("true"===r?r=!0:("false"===r||0===r)&&(r=!1)),r=!!r},Fe=function(e,n){let r=n.plane,i=n.plane.flipped();r=new L(r.normal,r.w),i=new L(i.normal,i.w+5*t.EPS);let o=e.cutByPlane(r);return o=o.cutByPlane(i),o.projectToOrthoNormalBasis(n)},Ie=function(e,t){if(0===e.polygons.length)return new o;let n=t.normal.times(t.w),r=0;e.polygons.map((function(e){e.vertices.map((function(e){let t=e.pos.distanceToSquared(n);t>r&&(r=t)}))})),r=Math.sqrt(r),r*=1.01;let i=[],s=new Y(t);i.push(new Q(s.to3D(new K(r,-r)))),i.push(new Q(s.to3D(new K(-r,-r)))),i.push(new Q(s.to3D(new K(-r,r)))),i.push(new Q(s.to3D(new K(r,r))));const l=new U(i,null,t.flipped()).extrude(t.normal.times(-r));let a=e.intersect(l);return a.properties=e.properties,a};function Ve(e,...t){const n=t.length>=1&&t[0].length?t[0]:t;let r=n[0];if(n.length>1)for(let e=1;e<n.length;e++)r=r.union(n[e]);return Array.isArray(e)||(e=[e,e,e]),r.center(e)}function qe(){let e={};const t={extrude2d:!1};let n,r=0,i=arguments;i[0].length&&(i=i[0]),"extrude2d"in i[0]&&(e=Object.assign({},t,i[0]),n=i[r++]),n=i[r++],"object"==typeof i[r]&&V(i[r])&&e.extrude2d&&(n=i[r].extrude({offset:[0,0,.1]}));for(;r<i.length;r++){let t=i[r];"object"==typeof i[r]&&V(i[r])&&e.extrude2d&&(t=i[r].extrude({offset:[0,0,.1]})),n=n.union(t)}return n}function Ne(){let e,t=0,n=arguments;for(n[0].length&&(n=n[0]),e=n[t++];t<n.length;t++)e=V(n[t])?e.subtract(n[t]):e.subtract(n[t].setColor(1,1,0));return e}window.staticTag=1,window.getTag=()=>window.staticTag++,n(o.prototype),n(J.prototype),n(i.prototype);export{X as Matrix4x4,ie as color,oe as cube,le as cylinder,ue as cylinderElliptic,ce as polyhedron,he as roundedCube,ae as roundedCylinder,se as sphere};
